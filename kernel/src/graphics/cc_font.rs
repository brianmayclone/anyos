/// Cape Coral Font — anti-aliased proportional font rendering.
///
/// Parses pre-rasterized .ccf font data (generated by tools/gen_cc_font.py)
/// and renders glyphs with alpha-blended coverage values.

use alloc::vec::Vec;
use crate::graphics::color::Color;
use crate::graphics::surface::Surface;
use crate::sync::spinlock::Spinlock;

/// Raw .ccf font data embedded at compile time
static CCF_DATA: &[u8] = include_bytes!("cape_coral.ccf");

/// Parsed font state (initialized after heap is available)
static FONT: Spinlock<Option<CcFont>> = Spinlock::new(None);

struct CcFont {
    sizes: Vec<FontSizeData>,
}

struct FontSizeData {
    size: u16,
    line_height: u16,
    ascent: i16,
    #[allow(dead_code)]
    descent: i16,
    glyphs: Vec<GlyphInfo>,
    coverage_offset: usize, // byte offset into CCF_DATA where coverage data starts
}

#[derive(Clone)]
struct GlyphInfo {
    codepoint: u32,
    advance_width: u16,
    bitmap_width: u16,
    bitmap_height: u16,
    x_offset: i16,
    y_offset: i16,
    bitmap_offset: u32,
}

/// Initialize the Cape Coral font (call after heap is available).
pub fn init() {
    if let Some(font) = parse_ccf(CCF_DATA) {
        let mut guard = FONT.lock();
        *guard = Some(font);
        crate::serial_println!("[OK] Cape Coral font initialized ({} sizes)",
            guard.as_ref().unwrap().sizes.len());
    } else {
        crate::serial_println!("[WARN] Failed to parse Cape Coral font data");
    }
}

/// Check if the font is initialized and ready.
pub fn is_ready() -> bool {
    FONT.lock().is_some()
}

/// Get line height for a given font size.
pub fn line_height(size: u16) -> u32 {
    let guard = FONT.lock();
    if let Some(font) = guard.as_ref() {
        if let Some(sd) = find_size(&font.sizes, size) {
            return sd.line_height as u32;
        }
    }
    size as u32 // fallback
}

/// Measure the pixel dimensions of a text string.
pub fn measure_string(text: &str, size: u16) -> (u32, u32) {
    let guard = FONT.lock();
    if let Some(font) = guard.as_ref() {
        if let Some(sd) = find_size(&font.sizes, size) {
            return measure_with_size(text, sd);
        }
    }
    // Fallback: estimate based on size
    let char_w = (size as u32 * 6) / 10; // ~0.6 ratio
    let mut max_width = 0u32;
    let mut current_width = 0u32;
    let mut lines = 1u32;
    for ch in text.chars() {
        if ch == '\n' {
            max_width = max_width.max(current_width);
            current_width = 0;
            lines += 1;
        } else {
            current_width += char_w;
        }
    }
    max_width = max_width.max(current_width);
    (max_width, lines * size as u32)
}

/// Draw an anti-aliased text string on a surface.
pub fn draw_string(surface: &mut Surface, x: i32, y: i32, text: &str, color: Color, size: u16) {
    let guard = FONT.lock();
    if let Some(font) = guard.as_ref() {
        if let Some(sd) = find_size(&font.sizes, size) {
            draw_with_size(surface, x, y, text, color, sd);
            return;
        }
    }
    // Fallback to bitmap font (use _bitmap to avoid recursion via font::draw_string)
    drop(guard);
    crate::graphics::font::draw_string_bitmap(surface, x, y, text, color);
}

/// Draw a single character and return its advance width.
pub fn draw_char(surface: &mut Surface, x: i32, y: i32, ch: char, color: Color, size: u16) -> u32 {
    let guard = FONT.lock();
    if let Some(font) = guard.as_ref() {
        if let Some(sd) = find_size(&font.sizes, size) {
            if let Some(glyph) = find_glyph(&sd.glyphs, ch as u32) {
                draw_glyph(surface, x, y, glyph, color, sd);
                return glyph.advance_width as u32;
            }
        }
    }
    // Fallback
    size as u32 * 6 / 10
}

// ─── Internal helpers ────────────────────────────────────────────────

fn find_size<'a>(sizes: &'a [FontSizeData], target: u16) -> Option<&'a FontSizeData> {
    // Exact match first
    if let Some(s) = sizes.iter().find(|s| s.size == target) {
        return Some(s);
    }
    // Nearest match
    sizes.iter().min_by_key(|s| (s.size as i32 - target as i32).unsigned_abs())
}

fn find_glyph(glyphs: &[GlyphInfo], codepoint: u32) -> Option<&GlyphInfo> {
    // Binary search since glyphs are sorted by codepoint
    glyphs.binary_search_by_key(&codepoint, |g| g.codepoint)
        .ok()
        .map(|idx| &glyphs[idx])
}

fn measure_with_size(text: &str, sd: &FontSizeData) -> (u32, u32) {
    let mut max_width = 0u32;
    let mut current_width = 0u32;
    let mut lines = 1u32;

    for ch in text.chars() {
        if ch == '\n' {
            max_width = max_width.max(current_width);
            current_width = 0;
            lines += 1;
        } else if ch == '\t' {
            // Tab = 4 spaces
            let space_w = find_glyph(&sd.glyphs, b' ' as u32)
                .map(|g| g.advance_width as u32)
                .unwrap_or(sd.size as u32 / 3);
            current_width += space_w * 4;
        } else {
            let advance = find_glyph(&sd.glyphs, ch as u32)
                .map(|g| g.advance_width as u32)
                .unwrap_or(sd.size as u32 * 6 / 10);
            current_width += advance;
        }
    }
    max_width = max_width.max(current_width);
    (max_width, lines * sd.line_height as u32)
}

fn draw_with_size(surface: &mut Surface, x: i32, y: i32, text: &str, color: Color, sd: &FontSizeData) {
    let mut cx = x;
    let mut cy = y;

    for ch in text.chars() {
        if ch == '\n' {
            cx = x;
            cy += sd.line_height as i32;
            continue;
        }
        if ch == '\t' {
            let space_w = find_glyph(&sd.glyphs, b' ' as u32)
                .map(|g| g.advance_width as u32)
                .unwrap_or(sd.size as u32 / 3);
            cx += (space_w * 4) as i32;
            continue;
        }

        if let Some(glyph) = find_glyph(&sd.glyphs, ch as u32) {
            draw_glyph(surface, cx, cy, glyph, color, sd);
            cx += glyph.advance_width as i32;
        } else {
            // Unknown character — advance by estimated width
            cx += (sd.size as i32) * 6 / 10;
        }
    }
}

fn draw_glyph(surface: &mut Surface, x: i32, y: i32, glyph: &GlyphInfo, color: Color, sd: &FontSizeData) {
    let bw = glyph.bitmap_width as i32;
    let bh = glyph.bitmap_height as i32;
    if bw == 0 || bh == 0 {
        return; // Space or empty glyph
    }

    let gx = x + glyph.x_offset as i32;
    let gy = y + glyph.y_offset as i32;

    let data_start = sd.coverage_offset + glyph.bitmap_offset as usize;
    let data_end = data_start + (bw * bh) as usize;
    if data_end > CCF_DATA.len() {
        return; // Invalid data
    }

    let sw = surface.width as i32;
    let sh = surface.height as i32;

    for row in 0..bh {
        let py = gy + row;
        if py < 0 || py >= sh { continue; }

        for col in 0..bw {
            let px = gx + col;
            if px < 0 || px >= sw { continue; }

            let coverage = CCF_DATA[data_start + (row * bw + col) as usize];
            if coverage == 0 { continue; }

            // Apply coverage as alpha
            let alpha = (coverage as u32 * color.a as u32) / 255;
            if alpha == 0 { continue; }

            let blended = Color::with_alpha(alpha as u8, color.r, color.g, color.b);
            surface.put_pixel(px, py, blended);
        }
    }
}

// ─── Parser ──────────────────────────────────────────────────────────

fn parse_ccf(data: &[u8]) -> Option<CcFont> {
    if data.len() < 8 { return None; }

    // Check magic
    if &data[0..4] != b"CCF\0" { return None; }

    let num_sizes = u32::from_le_bytes([data[4], data[5], data[6], data[7]]) as usize;
    if num_sizes == 0 || num_sizes > 16 { return None; }

    let mut offset = 8;
    let mut sizes = Vec::with_capacity(num_sizes);

    for _ in 0..num_sizes {
        if offset + 8 > data.len() { return None; }

        let font_size = u16::from_le_bytes([data[offset], data[offset + 1]]);
        let line_height = u16::from_le_bytes([data[offset + 2], data[offset + 3]]);
        let ascent = i16::from_le_bytes([data[offset + 4], data[offset + 5]]);
        let descent = i16::from_le_bytes([data[offset + 6], data[offset + 7]]);
        offset += 8;

        if offset + 4 > data.len() { return None; }
        let num_glyphs = u16::from_le_bytes([data[offset], data[offset + 1]]) as usize;
        let _padding = u16::from_le_bytes([data[offset + 2], data[offset + 3]]);
        offset += 4;

        // Parse glyph table (18 bytes per glyph: u32 + 3*u16 + 2*i16 + u32)
        let glyph_table_size = num_glyphs * 18;
        if offset + glyph_table_size > data.len() { return None; }

        let mut glyphs = Vec::with_capacity(num_glyphs);
        for _ in 0..num_glyphs {
            let codepoint = u32::from_le_bytes([
                data[offset], data[offset + 1], data[offset + 2], data[offset + 3],
            ]);
            let advance_width = u16::from_le_bytes([data[offset + 4], data[offset + 5]]);
            let bitmap_width = u16::from_le_bytes([data[offset + 6], data[offset + 7]]);
            let bitmap_height = u16::from_le_bytes([data[offset + 8], data[offset + 9]]);
            let x_offset = i16::from_le_bytes([data[offset + 10], data[offset + 11]]);
            let y_offset = i16::from_le_bytes([data[offset + 12], data[offset + 13]]);
            let bitmap_offset = u32::from_le_bytes([
                data[offset + 14], data[offset + 15], data[offset + 16], data[offset + 17],
            ]);
            // bytes 18-19 are padding from struct alignment, but our format packs tightly at 18 bytes
            offset += 18;

            glyphs.push(GlyphInfo {
                codepoint,
                advance_width,
                bitmap_width,
                bitmap_height,
                x_offset,
                y_offset,
                bitmap_offset,
            });
        }

        // Coverage data starts here; compute total coverage size for this size block
        let mut total_coverage = 0usize;
        for g in &glyphs {
            let end = g.bitmap_offset as usize + (g.bitmap_width as usize * g.bitmap_height as usize);
            if end > total_coverage {
                total_coverage = end;
            }
        }

        let coverage_offset = offset;
        offset += total_coverage;

        sizes.push(FontSizeData {
            size: font_size,
            line_height,
            ascent,
            descent,
            glyphs,
            coverage_offset,
        });
    }

    Some(CcFont { sizes })
}
