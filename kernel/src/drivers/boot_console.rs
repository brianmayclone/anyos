/// Boot splash — displays the color boot logo on the VESA framebuffer
/// during boot, similar to Apple's boot screen.
/// No heap required, renders directly to framebuffer memory.
/// In error/panic mode, falls back to text display.

use crate::graphics::font::{FONT_WIDTH, FONT_HEIGHT};
use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};

static FB_ADDR: AtomicU32 = AtomicU32::new(0);
static FB_PITCH: AtomicU32 = AtomicU32::new(0);
static FB_WIDTH: AtomicU32 = AtomicU32::new(0);
static FB_HEIGHT: AtomicU32 = AtomicU32::new(0);
static ERROR_MODE: AtomicBool = AtomicBool::new(false);
static CURSOR_X: AtomicU32 = AtomicU32::new(8);
static CURSOR_Y: AtomicU32 = AtomicU32::new(8);

const BG_COLOR: u32 = 0xFF000000;   // black to fix the logo colors (no alpha blending with random desktop background)

/// Boot logo data (raw RGBA, generated by tools/convert_boot_logo.py)
/// Format: [width:u32 LE][height:u32 LE][RGBA pixel data]
static BOOT_LOGO: &[u8] = include_bytes!("../graphics/boot_logo.bin");

/// Font data for error mode text (same as graphics::font)
static FONT_DATA: &[u8] = include_bytes!("../graphics/font_8x16.bin");

pub fn init() {
    if let Some(fb) = crate::drivers::framebuffer::info() {
        FB_ADDR.store(fb.addr, Ordering::Relaxed);
        FB_PITCH.store(fb.pitch, Ordering::Relaxed);
        FB_WIDTH.store(fb.width, Ordering::Relaxed);
        FB_HEIGHT.store(fb.height, Ordering::Relaxed);
        show_splash();
    }
}

fn is_ready() -> bool {
    FB_ADDR.load(Ordering::Relaxed) != 0
}

fn put_pixel(x: u32, y: u32, color: u32) {
    let addr = FB_ADDR.load(Ordering::Relaxed);
    let pitch = FB_PITCH.load(Ordering::Relaxed);
    let ptr = (addr + y * pitch + x * 4) as *mut u32;
    unsafe { ptr.write_volatile(color); }
}

fn clear_screen(color: u32) {
    let addr = FB_ADDR.load(Ordering::Relaxed);
    let pitch = FB_PITCH.load(Ordering::Relaxed);
    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);
    for y in 0..height {
        let row = (addr + y * pitch) as *mut u32;
        for x in 0..width {
            unsafe { row.add(x as usize).write_volatile(color); }
        }
    }
}

/// Parse logo header and get dimensions + pixel data offset
fn parse_logo() -> Option<(u32, u32, usize)> {
    if BOOT_LOGO.len() < 8 {
        return None;
    }
    let width = u32::from_le_bytes([BOOT_LOGO[0], BOOT_LOGO[1], BOOT_LOGO[2], BOOT_LOGO[3]]);
    let height = u32::from_le_bytes([BOOT_LOGO[4], BOOT_LOGO[5], BOOT_LOGO[6], BOOT_LOGO[7]]);
    let expected = 8 + (width * height * 4) as usize;
    if BOOT_LOGO.len() < expected || width == 0 || height == 0 {
        return None;
    }
    Some((width, height, 8))
}

/// Show the boot splash: dark screen with centered color logo.
fn show_splash() {
    clear_screen(BG_COLOR);

    let (logo_w, logo_h, data_offset) = match parse_logo() {
        Some(v) => v,
        None => return, // No valid logo data
    };

    let fb_w = FB_WIDTH.load(Ordering::Relaxed);
    let fb_h = FB_HEIGHT.load(Ordering::Relaxed);

    // Center the logo
    let start_x = if fb_w > logo_w { (fb_w - logo_w) / 2 } else { 0 };
    let start_y = if fb_h > logo_h { (fb_h - logo_h) / 2 } else { 0 };

    // Blit logo pixels with alpha blending against background
    let bg_r = ((BG_COLOR >> 16) & 0xFF) as u32;
    let bg_g = ((BG_COLOR >> 8) & 0xFF) as u32;
    let bg_b = (BG_COLOR & 0xFF) as u32;

    for ly in 0..logo_h {
        let screen_y = start_y + ly;
        if screen_y >= fb_h { break; }

        for lx in 0..logo_w {
            let screen_x = start_x + lx;
            if screen_x >= fb_w { break; }

            let idx = data_offset + ((ly * logo_w + lx) * 4) as usize;
            let r = BOOT_LOGO[idx] as u32;
            let g = BOOT_LOGO[idx + 1] as u32;
            let b = BOOT_LOGO[idx + 2] as u32;
            let a = BOOT_LOGO[idx + 3] as u32;

            if a == 0 {
                continue; // Fully transparent, skip
            }

            let out_r;
            let out_g;
            let out_b;

            if a == 255 {
                out_r = r;
                out_g = g;
                out_b = b;
            } else {
                // Alpha blend: out = src * a/255 + bg * (255-a)/255
                let inv_a = 255 - a;
                out_r = (r * a + bg_r * inv_a) / 255;
                out_g = (g * a + bg_g * inv_a) / 255;
                out_b = (b * a + bg_b * inv_a) / 255;
            }

            let pixel = 0xFF000000 | (out_r << 16) | (out_g << 8) | out_b;
            put_pixel(screen_x, screen_y, pixel);
        }
    }
}

/// Switch to error mode — clear screen and start showing text.
pub fn enter_error_mode() {
    if !is_ready() { return; }
    ERROR_MODE.store(true, Ordering::Relaxed);
    clear_screen(0xFF1A0000); // very dark red
    CURSOR_X.store(8, Ordering::Relaxed);
    CURSOR_Y.store(8, Ordering::Relaxed);
}

/// Draw a character at (cx, cy) using the bitmap font for error text.
fn draw_char_1x(cx: u32, cy: u32, ch: u8, color: u32) {
    let c = ch as u32;
    if c < 32 || c > 126 { return; }
    let idx = (c - 32) as usize;
    let glyph_offset = idx * FONT_HEIGHT as usize;
    if glyph_offset + FONT_HEIGHT as usize > FONT_DATA.len() { return; }

    let fb_w = FB_WIDTH.load(Ordering::Relaxed);
    let fb_h = FB_HEIGHT.load(Ordering::Relaxed);

    for row in 0..FONT_HEIGHT {
        let bits = FONT_DATA[glyph_offset + row as usize];
        for col in 0..FONT_WIDTH {
            if bits & (0x80 >> col) != 0 {
                let x = cx + col;
                let y = cy + row;
                if x < fb_w && y < fb_h {
                    put_pixel(x, y, color);
                }
            }
        }
    }
}

/// Write text in error mode.
pub fn error_write_str(s: &str) {
    if !is_ready() || !ERROR_MODE.load(Ordering::Relaxed) { return; }
    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);
    let mut cx = CURSOR_X.load(Ordering::Relaxed);
    let mut cy = CURSOR_Y.load(Ordering::Relaxed);

    for byte in s.bytes() {
        match byte {
            b'\n' => {
                cx = 8;
                cy += FONT_HEIGHT;
                if cy + FONT_HEIGHT > height { cy = 8; }
            }
            b'\r' => { cx = 8; }
            _ => {
                if cx + FONT_WIDTH <= width {
                    draw_char_1x(cx, cy, byte, 0xFFFF4444);
                }
                cx += FONT_WIDTH;
                if cx + FONT_WIDTH > width {
                    cx = 8;
                    cy += FONT_HEIGHT;
                    if cy + FONT_HEIGHT > height { cy = 8; }
                }
            }
        }
    }

    CURSOR_X.store(cx, Ordering::Relaxed);
    CURSOR_Y.store(cy, Ordering::Relaxed);
}

/// Formatted error output writer.
pub struct ErrorWriter;

impl core::fmt::Write for ErrorWriter {
    fn write_str(&mut self, s: &str) -> core::fmt::Result {
        error_write_str(s);
        Ok(())
    }
}
