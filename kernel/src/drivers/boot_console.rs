//! Boot splash screen and early error console.
//!
//! Displays a centered boot logo on the VESA framebuffer during startup.
//! No heap required -- renders directly to framebuffer memory. Falls back
//! to a bitmap text console for panic/error output on a dark red background.

use crate::graphics::font::{FONT_WIDTH, FONT_HEIGHT};
use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};

static FB_ADDR: AtomicU32 = AtomicU32::new(0);
static FB_PITCH: AtomicU32 = AtomicU32::new(0);
static FB_WIDTH: AtomicU32 = AtomicU32::new(0);
static FB_HEIGHT: AtomicU32 = AtomicU32::new(0);
static ERROR_MODE: AtomicBool = AtomicBool::new(false);
static CURSOR_X: AtomicU32 = AtomicU32::new(8);
static CURSOR_Y: AtomicU32 = AtomicU32::new(8);

// --- Spinner state ---
static SPINNER_ACTIVE: AtomicBool = AtomicBool::new(false);
static SPINNER_LAST_PHASE: AtomicU32 = AtomicU32::new(u32::MAX);
static SPINNER_CX: AtomicU32 = AtomicU32::new(0);
static SPINNER_CY: AtomicU32 = AtomicU32::new(0);

const BG_COLOR: u32 = 0xFF000000;   // base black (used for clear_rect / error mode)
const BG_GRADIENT_TOP: u32 = 0xFF0D0D14;  // dark blue-gray
const BG_GRADIENT_BOT: u32 = 0xFF020204;  // near-black

/// Boot logo data (raw RGBA, generated by tools/convert_boot_logo.py)
/// Format: [width:u32 LE][height:u32 LE][RGBA pixel data]
static BOOT_LOGO: &[u8] = include_bytes!("../graphics/boot_logo.bin");

/// Font data for error mode text (same as graphics::font)
static FONT_DATA: &[u8] = include_bytes!("../graphics/font_8x16.bin");

/// Initialize the boot splash screen from the framebuffer and display the logo.
/// Registers a framebuffer change hook so the splash is automatically redrawn
/// when a GPU driver changes resolution or switches backing buffers.
pub fn init() {
    // Register for framebuffer change notifications — any GPU driver that calls
    // framebuffer::update() will trigger on_fb_changed() automatically.
    crate::drivers::framebuffer::register_change_hook(on_fb_changed);

    if let Some(fb) = crate::drivers::framebuffer::info() {
        FB_ADDR.store(fb.addr, Ordering::Relaxed);
        FB_PITCH.store(fb.pitch, Ordering::Relaxed);
        FB_WIDTH.store(fb.width, Ordering::Relaxed);
        FB_HEIGHT.store(fb.height, Ordering::Relaxed);
        show_splash();
    }
}

/// Framebuffer change hook — called by framebuffer::update() when a GPU driver
/// changes the active display. Re-renders the splash centered for the new resolution.
fn on_fb_changed(addr: u32, pitch: u32, width: u32, height: u32) {
    FB_ADDR.store(addr, Ordering::Relaxed);
    FB_PITCH.store(pitch, Ordering::Relaxed);
    FB_WIDTH.store(width, Ordering::Relaxed);
    FB_HEIGHT.store(height, Ordering::Relaxed);

    if SPINNER_ACTIVE.load(Ordering::Relaxed) && !ERROR_MODE.load(Ordering::Relaxed) {
        show_splash();
    }
}

fn is_ready() -> bool {
    FB_ADDR.load(Ordering::Relaxed) != 0
}

fn put_pixel(x: u32, y: u32, color: u32) {
    let addr = FB_ADDR.load(Ordering::Relaxed);
    let pitch = FB_PITCH.load(Ordering::Relaxed);
    let ptr = (addr + y * pitch + x * 4) as *mut u32;
    unsafe { ptr.write_volatile(color); }
}

fn clear_screen(color: u32) {
    let addr = FB_ADDR.load(Ordering::Relaxed);
    let pitch = FB_PITCH.load(Ordering::Relaxed);
    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);
    for y in 0..height {
        let row = (addr + y * pitch) as *mut u32;
        for x in 0..width {
            unsafe { row.add(x as usize).write_volatile(color); }
        }
    }
}

/// Parse logo header and get dimensions + pixel data offset
fn parse_logo() -> Option<(u32, u32, usize)> {
    if BOOT_LOGO.len() < 8 {
        return None;
    }
    let width = u32::from_le_bytes([BOOT_LOGO[0], BOOT_LOGO[1], BOOT_LOGO[2], BOOT_LOGO[3]]);
    let height = u32::from_le_bytes([BOOT_LOGO[4], BOOT_LOGO[5], BOOT_LOGO[6], BOOT_LOGO[7]]);
    let expected = 8 + (width * height * 4) as usize;
    if BOOT_LOGO.len() < expected || width == 0 || height == 0 {
        return None;
    }
    Some((width, height, 8))
}

/// Fill the screen with a vertical gradient (top_color → bottom_color).
fn fill_gradient_screen(top: u32, bot: u32) {
    let addr = FB_ADDR.load(Ordering::Relaxed);
    let pitch = FB_PITCH.load(Ordering::Relaxed);
    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);
    if height == 0 { return; }
    let denom = height.saturating_sub(1).max(1);
    for y in 0..height {
        let t = y;
        let r = ((top >> 16) & 0xFF) as i32 + (((bot >> 16) & 0xFF) as i32 - ((top >> 16) & 0xFF) as i32) * t as i32 / denom as i32;
        let g = ((top >> 8) & 0xFF) as i32 + (((bot >> 8) & 0xFF) as i32 - ((top >> 8) & 0xFF) as i32) * t as i32 / denom as i32;
        let b = (top & 0xFF) as i32 + ((bot & 0xFF) as i32 - (top & 0xFF) as i32) * t as i32 / denom as i32;
        let color = 0xFF000000 | ((r as u32 & 0xFF) << 16) | ((g as u32 & 0xFF) << 8) | (b as u32 & 0xFF);
        let row = (addr + y * pitch) as *mut u32;
        for x in 0..width {
            unsafe { row.add(x as usize).write_volatile(color); }
        }
    }
}

/// Show the boot splash: gradient screen with centered color logo + spinner.
///
/// Also used during shutdown to display the boot logo before power-off.
pub fn show_splash() {
    fill_gradient_screen(BG_GRADIENT_TOP, BG_GRADIENT_BOT);

    let (logo_w, logo_h, data_offset) = match parse_logo() {
        Some(v) => v,
        None => return, // No valid logo data
    };

    let fb_w = FB_WIDTH.load(Ordering::Relaxed);
    let fb_h = FB_HEIGHT.load(Ordering::Relaxed);

    // Center the logo
    let start_x = if fb_w > logo_w { (fb_w - logo_w) / 2 } else { 0 };
    let start_y = if fb_h > logo_h { (fb_h - logo_h) / 2 } else { 0 };

    // Blit logo pixels with alpha blending against gradient background
    let denom = if fb_h > 1 { fb_h - 1 } else { 1 };

    for ly in 0..logo_h {
        let screen_y = start_y + ly;
        if screen_y >= fb_h { break; }

        // Compute gradient background color for this row
        let t = screen_y;
        let bg_r = (((BG_GRADIENT_TOP >> 16) & 0xFF) as i32 + (((BG_GRADIENT_BOT >> 16) & 0xFF) as i32 - ((BG_GRADIENT_TOP >> 16) & 0xFF) as i32) * t as i32 / denom as i32) as u32;
        let bg_g = (((BG_GRADIENT_TOP >> 8) & 0xFF) as i32 + (((BG_GRADIENT_BOT >> 8) & 0xFF) as i32 - ((BG_GRADIENT_TOP >> 8) & 0xFF) as i32) * t as i32 / denom as i32) as u32;
        let bg_b = ((BG_GRADIENT_TOP & 0xFF) as i32 + ((BG_GRADIENT_BOT & 0xFF) as i32 - (BG_GRADIENT_TOP & 0xFF) as i32) * t as i32 / denom as i32) as u32;

        for lx in 0..logo_w {
            let screen_x = start_x + lx;
            if screen_x >= fb_w { break; }

            let idx = data_offset + ((ly * logo_w + lx) * 4) as usize;
            let r = BOOT_LOGO[idx] as u32;
            let g = BOOT_LOGO[idx + 1] as u32;
            let b = BOOT_LOGO[idx + 2] as u32;
            let a = BOOT_LOGO[idx + 3] as u32;

            if a == 0 {
                continue; // Fully transparent, skip
            }

            let out_r;
            let out_g;
            let out_b;

            if a == 255 {
                out_r = r;
                out_g = g;
                out_b = b;
            } else {
                // Alpha blend: out = src * a/255 + bg * (255-a)/255
                let inv_a = 255 - a;
                out_r = (r * a + bg_r * inv_a) / 255;
                out_g = (g * a + bg_g * inv_a) / 255;
                out_b = (b * a + bg_b * inv_a) / 255;
            }

            let pixel = 0xFF000000 | (out_r << 16) | (out_g << 8) | out_b;
            put_pixel(screen_x, screen_y, pixel);
        }
    }

    // Set spinner center: horizontally centered, below logo
    let logo_bottom = start_y + logo_h;
    SPINNER_CX.store(fb_w / 2, Ordering::Relaxed);
    SPINNER_CY.store(logo_bottom + SPINNER_Y_BELOW_LOGO, Ordering::Relaxed);
    SPINNER_ACTIVE.store(true, Ordering::Relaxed);
}

// --- Spinning loading indicator (Windows 11 style) ---
//
// Draws a ring of dots below the boot logo. A "tail" of 5 dots chases
// around the circle, with the leading dot brightest. Rotates once per
// second (12 steps). Driven by TSC timing — safe to call from IRQ context.

const SPINNER_RING_RADIUS: i32 = 18;  // distance from center to each dot
const SPINNER_DOT_RADIUS: i32 = 2;    // radius of each dot
const SPINNER_NUM_DOTS: usize = 12;   // positions around the ring
const SPINNER_TAIL_LEN: usize = 5;    // number of visible trailing dots
const SPINNER_Y_BELOW_LOGO: u32 = 40; // pixels below the logo bottom

/// Fixed-point cos*1024 for 12 equally spaced positions (clockwise from top).
const FCOS12: [i32; 12] = [0, 512, 887, 1024, 887, 512, 0, -512, -887, -1024, -887, -512];
/// Fixed-point sin*1024 (top = negative Y on screen).
const FSIN12: [i32; 12] = [-1024, -887, -512, 0, 512, 887, 1024, 887, 512, 0, -512, -887];

/// Brightness for each tail dot (index 0 = leading/brightest).
const TAIL_BRIGHT: [u32; SPINNER_TAIL_LEN] = [255, 190, 130, 70, 30];

/// Advance the spinner animation. Called from PIT IRQ handler and manually
/// during boot phases. Returns immediately if spinner is inactive or phase
/// hasn't changed since last call.
pub fn tick_spinner() {
    if !SPINNER_ACTIVE.load(Ordering::Relaxed) { return; }
    if ERROR_MODE.load(Ordering::Relaxed) {
        SPINNER_ACTIVE.store(false, Ordering::Relaxed);
        return;
    }

    // Compute animation phase from TSC (one full rotation per second)
    let tsc_hz = crate::arch::x86::pit::tsc_hz();
    let tsc = crate::arch::x86::pit::rdtsc();
    let step_cycles = if tsc_hz > 0 {
        tsc_hz / SPINNER_NUM_DOTS as u64
    } else {
        // Before TSC calibration: assume ~1 GHz (works for 0.5–4 GHz)
        1_000_000_000u64 / SPINNER_NUM_DOTS as u64
    };
    if step_cycles == 0 { return; }
    let phase = ((tsc / step_cycles) % SPINNER_NUM_DOTS as u64) as u32;

    let prev = SPINNER_LAST_PHASE.swap(phase, Ordering::Relaxed);
    if phase == prev { return; }

    draw_spinner(phase);
}

/// Stop the spinner animation (called when compositor takes over).
pub fn stop_spinner() {
    if !SPINNER_ACTIVE.load(Ordering::Relaxed) { return; }
    SPINNER_ACTIVE.store(false, Ordering::Relaxed);

    // Erase spinner area
    let cx = SPINNER_CX.load(Ordering::Relaxed) as i32;
    let cy = SPINNER_CY.load(Ordering::Relaxed) as i32;
    let fb_w = FB_WIDTH.load(Ordering::Relaxed);
    let fb_h = FB_HEIGHT.load(Ordering::Relaxed);
    let clear_r = SPINNER_RING_RADIUS + SPINNER_DOT_RADIUS + 2;
    clear_rect(cx - clear_r, cy - clear_r, clear_r * 2 + 1, clear_r * 2 + 1, fb_w, fb_h);
}

fn draw_spinner(phase: u32) {
    let cx = SPINNER_CX.load(Ordering::Relaxed) as i32;
    let cy = SPINNER_CY.load(Ordering::Relaxed) as i32;
    if cx == 0 && cy == 0 { return; }

    let fb_w = FB_WIDTH.load(Ordering::Relaxed);
    let fb_h = FB_HEIGHT.load(Ordering::Relaxed);

    // Clear spinner bounding box
    let clear_r = SPINNER_RING_RADIUS + SPINNER_DOT_RADIUS + 2;
    clear_rect(cx - clear_r, cy - clear_r, clear_r * 2 + 1, clear_r * 2 + 1, fb_w, fb_h);

    // Draw tail dots (back-to-front so leading dot is on top)
    for t in (0..SPINNER_TAIL_LEN).rev() {
        let dot_idx = (phase as usize + SPINNER_NUM_DOTS - t) % SPINNER_NUM_DOTS;
        let bright = TAIL_BRIGHT[t];
        let color = 0xFF000000 | (bright << 16) | (bright << 8) | bright;

        let dot_x = cx + FCOS12[dot_idx] * SPINNER_RING_RADIUS / 1024;
        let dot_y = cy + FSIN12[dot_idx] * SPINNER_RING_RADIUS / 1024;

        draw_filled_circle(dot_x, dot_y, SPINNER_DOT_RADIUS, color, fb_w, fb_h);
    }
}

fn clear_rect(x: i32, y: i32, w: i32, h: i32, fb_w: u32, fb_h: u32) {
    let addr = FB_ADDR.load(Ordering::Relaxed);
    let pitch = FB_PITCH.load(Ordering::Relaxed);
    let denom = if fb_h > 1 { fb_h - 1 } else { 1 };
    for dy in 0..h {
        let py = y + dy;
        if py < 0 || py as u32 >= fb_h { continue; }
        // Compute gradient background for this row
        let t = py as u32;
        let gr = (((BG_GRADIENT_TOP >> 16) & 0xFF) as i32 + (((BG_GRADIENT_BOT >> 16) & 0xFF) as i32 - ((BG_GRADIENT_TOP >> 16) & 0xFF) as i32) * t as i32 / denom as i32) as u32;
        let gg = (((BG_GRADIENT_TOP >> 8) & 0xFF) as i32 + (((BG_GRADIENT_BOT >> 8) & 0xFF) as i32 - ((BG_GRADIENT_TOP >> 8) & 0xFF) as i32) * t as i32 / denom as i32) as u32;
        let gb = ((BG_GRADIENT_TOP & 0xFF) as i32 + ((BG_GRADIENT_BOT & 0xFF) as i32 - (BG_GRADIENT_TOP & 0xFF) as i32) * t as i32 / denom as i32) as u32;
        let row_color = 0xFF000000 | ((gr & 0xFF) << 16) | ((gg & 0xFF) << 8) | (gb & 0xFF);
        let row = (addr + py as u32 * pitch) as *mut u32;
        for dx in 0..w {
            let px = x + dx;
            if px >= 0 && (px as u32) < fb_w {
                unsafe { row.add(px as usize).write_volatile(row_color); }
            }
        }
    }
}

fn draw_filled_circle(cx: i32, cy: i32, r: i32, color: u32, fb_w: u32, fb_h: u32) {
    let r2 = r * r;
    for dy in -r..=r {
        for dx in -r..=r {
            if dx * dx + dy * dy <= r2 {
                let px = cx + dx;
                let py = cy + dy;
                if px >= 0 && py >= 0 && (px as u32) < fb_w && (py as u32) < fb_h {
                    put_pixel(px as u32, py as u32, color);
                }
            }
        }
    }
}

/// Switch to error mode — clear screen and start showing text.
pub fn enter_error_mode() {
    if !is_ready() { return; }
    ERROR_MODE.store(true, Ordering::Relaxed);
    clear_screen(0xFF1A0000); // very dark red
    CURSOR_X.store(8, Ordering::Relaxed);
    CURSOR_Y.store(8, Ordering::Relaxed);
}

/// Draw a character at (cx, cy) using the bitmap font for error text.
fn draw_char_1x(cx: u32, cy: u32, ch: u8, color: u32) {
    let c = ch as u32;
    if c < 32 || c > 126 { return; }
    let idx = (c - 32) as usize;
    let glyph_offset = idx * FONT_HEIGHT as usize;
    if glyph_offset + FONT_HEIGHT as usize > FONT_DATA.len() { return; }

    let fb_w = FB_WIDTH.load(Ordering::Relaxed);
    let fb_h = FB_HEIGHT.load(Ordering::Relaxed);

    for row in 0..FONT_HEIGHT {
        let bits = FONT_DATA[glyph_offset + row as usize];
        for col in 0..FONT_WIDTH {
            if bits & (0x80 >> col) != 0 {
                let x = cx + col;
                let y = cy + row;
                if x < fb_w && y < fb_h {
                    put_pixel(x, y, color);
                }
            }
        }
    }
}

/// Write text in error mode.
pub fn error_write_str(s: &str) {
    if !is_ready() || !ERROR_MODE.load(Ordering::Relaxed) { return; }
    let width = FB_WIDTH.load(Ordering::Relaxed);
    let height = FB_HEIGHT.load(Ordering::Relaxed);
    let mut cx = CURSOR_X.load(Ordering::Relaxed);
    let mut cy = CURSOR_Y.load(Ordering::Relaxed);

    for byte in s.bytes() {
        match byte {
            b'\n' => {
                cx = 8;
                cy += FONT_HEIGHT;
                if cy + FONT_HEIGHT > height { cy = 8; }
            }
            b'\r' => { cx = 8; }
            _ => {
                if cx + FONT_WIDTH <= width {
                    draw_char_1x(cx, cy, byte, 0xFFFF4444);
                }
                cx += FONT_WIDTH;
                if cx + FONT_WIDTH > width {
                    cx = 8;
                    cy += FONT_HEIGHT;
                    if cy + FONT_HEIGHT > height { cy = 8; }
                }
            }
        }
    }

    CURSOR_X.store(cx, Ordering::Relaxed);
    CURSOR_Y.store(cy, Ordering::Relaxed);
}

/// Formatted error output writer.
pub struct ErrorWriter;

impl core::fmt::Write for ErrorWriter {
    fn write_str(&mut self, s: &str) -> core::fmt::Result {
        error_write_str(s);
        Ok(())
    }
}
