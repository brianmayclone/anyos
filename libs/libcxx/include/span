/*
 * Copyright (c) 2024-2026 Christian Moeller
 * SPDX-License-Identifier: MIT
 *
 * <span> — non-owning contiguous range view (C++20).
 */

#ifndef _LIBCXX_SPAN
#define _LIBCXX_SPAN

#include <cstddef>
#include <iterator>
#include <type_traits>
#include <array>

namespace std {

inline constexpr size_t dynamic_extent = size_t(-1);

/* ── span (dynamic extent) ─────────────────────────────────────────── */

template <class T, size_t Extent = dynamic_extent>
class span;

/* Dynamic extent specialization */
template <class T>
class span<T, dynamic_extent> {
public:
    using element_type    = T;
    using value_type      = remove_cv_t<T>;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = T*;
    using const_pointer   = const T*;
    using reference       = T&;
    using const_reference = const T&;
    using iterator        = T*;
    using const_iterator  = const T*;
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    static constexpr size_type extent = dynamic_extent;

private:
    pointer   _data;
    size_type _size;

public:
    constexpr span() noexcept : _data(nullptr), _size(0) {}
    constexpr span(pointer ptr, size_type count) : _data(ptr), _size(count) {}
    constexpr span(pointer first, pointer last) : _data(first), _size(last - first) {}

    template <size_t N>
    constexpr span(T (&arr)[N]) noexcept : _data(arr), _size(N) {}

    template <class U, size_t N>
    constexpr span(array<U, N>& arr) noexcept : _data(arr.data()), _size(N) {}

    template <class U, size_t N>
    constexpr span(const array<U, N>& arr) noexcept : _data(arr.data()), _size(N) {}

    constexpr span(const span&) noexcept = default;
    constexpr span& operator=(const span&) noexcept = default;

    /* Element access */
    constexpr reference operator[](size_type idx) const { return _data[idx]; }
    constexpr reference front() const { return _data[0]; }
    constexpr reference back()  const { return _data[_size - 1]; }
    constexpr pointer   data()  const noexcept { return _data; }

    /* Iterators */
    constexpr iterator       begin()  const noexcept { return _data; }
    constexpr iterator       end()    const noexcept { return _data + _size; }
    constexpr const_iterator cbegin() const noexcept { return _data; }
    constexpr const_iterator cend()   const noexcept { return _data + _size; }

    constexpr reverse_iterator       rbegin()  const noexcept { return reverse_iterator(end()); }
    constexpr reverse_iterator       rend()    const noexcept { return reverse_iterator(begin()); }

    /* Capacity */
    constexpr size_type size()       const noexcept { return _size; }
    constexpr size_type size_bytes() const noexcept { return _size * sizeof(T); }
    [[nodiscard]] constexpr bool empty() const noexcept { return _size == 0; }

    /* Subviews */
    constexpr span first(size_type count) const {
        return span(_data, count);
    }

    constexpr span last(size_type count) const {
        return span(_data + _size - count, count);
    }

    constexpr span subspan(size_type offset, size_type count = dynamic_extent) const {
        if (count == dynamic_extent) count = _size - offset;
        return span(_data + offset, count);
    }
};

/* ── span (static extent) ──────────────────────────────────────────── */

template <class T, size_t Extent>
class span {
public:
    using element_type    = T;
    using value_type      = remove_cv_t<T>;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = T*;
    using const_pointer   = const T*;
    using reference       = T&;
    using const_reference = const T&;
    using iterator        = T*;
    using const_iterator  = const T*;
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    static constexpr size_type extent = Extent;

private:
    pointer _data;

public:
    constexpr span() noexcept : _data(nullptr) {
        static_assert(Extent == 0, "cannot default-construct non-zero span");
    }

    constexpr span(pointer ptr, size_type) : _data(ptr) {}
    constexpr span(pointer first, pointer) : _data(first) {}

    constexpr span(T (&arr)[Extent]) noexcept : _data(arr) {}

    template <class U>
    constexpr span(array<U, Extent>& arr) noexcept : _data(arr.data()) {}

    constexpr span(const span&) noexcept = default;
    constexpr span& operator=(const span&) noexcept = default;

    /* Implicit conversion to dynamic span */
    constexpr operator span<T, dynamic_extent>() const noexcept {
        return span<T, dynamic_extent>(_data, Extent);
    }

    /* Element access */
    constexpr reference operator[](size_type idx) const { return _data[idx]; }
    constexpr reference front() const { return _data[0]; }
    constexpr reference back()  const { return _data[Extent - 1]; }
    constexpr pointer   data()  const noexcept { return _data; }

    /* Iterators */
    constexpr iterator       begin()  const noexcept { return _data; }
    constexpr iterator       end()    const noexcept { return _data + Extent; }
    constexpr const_iterator cbegin() const noexcept { return _data; }
    constexpr const_iterator cend()   const noexcept { return _data + Extent; }

    constexpr reverse_iterator rbegin() const noexcept { return reverse_iterator(end()); }
    constexpr reverse_iterator rend()   const noexcept { return reverse_iterator(begin()); }

    /* Capacity */
    constexpr size_type size()       const noexcept { return Extent; }
    constexpr size_type size_bytes() const noexcept { return Extent * sizeof(T); }
    [[nodiscard]] constexpr bool empty() const noexcept { return Extent == 0; }

    /* Subviews */
    constexpr span<T, dynamic_extent> first(size_type count) const {
        return {_data, count};
    }

    constexpr span<T, dynamic_extent> last(size_type count) const {
        return {_data + Extent - count, count};
    }

    constexpr span<T, dynamic_extent> subspan(size_type offset,
                                               size_type count = dynamic_extent) const {
        if (count == dynamic_extent) count = Extent - offset;
        return {_data + offset, count};
    }
};

/* ── as_bytes / as_writable_bytes ──────────────────────────────────── */

template <class T, size_t N>
span<const unsigned char, dynamic_extent>
as_bytes(span<T, N> s) noexcept {
    return {reinterpret_cast<const unsigned char*>(s.data()), s.size_bytes()};
}

template <class T, size_t N>
span<unsigned char, dynamic_extent>
as_writable_bytes(span<T, N> s) noexcept {
    return {reinterpret_cast<unsigned char*>(s.data()), s.size_bytes()};
}

} // namespace std

#endif
