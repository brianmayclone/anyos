/*
 * Copyright (c) 2024-2026 Christian Moeller
 * SPDX-License-Identifier: MIT
 *
 * <iterator> — iterator traits, categories, reverse_iterator, helpers.
 */

#ifndef _LIBCXX_ITERATOR
#define _LIBCXX_ITERATOR

#include <cstddef>
#include <type_traits>

namespace std {

/* ── Iterator category tags ────────────────────────────────────────── */

struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag       : input_iterator_tag {};
struct bidirectional_iterator_tag : forward_iterator_tag {};
struct random_access_iterator_tag : bidirectional_iterator_tag {};
struct contiguous_iterator_tag    : random_access_iterator_tag {};

/* ── iterator_traits ───────────────────────────────────────────────── */

template <class Iter, class = void>
struct iterator_traits {};

template <class Iter>
struct iterator_traits<Iter, void_t<
    typename Iter::difference_type,
    typename Iter::value_type,
    typename Iter::pointer,
    typename Iter::reference,
    typename Iter::iterator_category
>> {
    using difference_type   = typename Iter::difference_type;
    using value_type        = typename Iter::value_type;
    using pointer           = typename Iter::pointer;
    using reference         = typename Iter::reference;
    using iterator_category = typename Iter::iterator_category;
};

/* Pointer specialization */
template <class T>
struct iterator_traits<T*> {
    using difference_type   = ptrdiff_t;
    using value_type        = remove_cv_t<T>;
    using pointer           = T*;
    using reference         = T&;
    using iterator_category = random_access_iterator_tag;
};

/* ── reverse_iterator ──────────────────────────────────────────────── */

template <class Iter>
class reverse_iterator {
public:
    using iterator_type     = Iter;
    using difference_type   = typename iterator_traits<Iter>::difference_type;
    using value_type        = typename iterator_traits<Iter>::value_type;
    using pointer           = typename iterator_traits<Iter>::pointer;
    using reference         = typename iterator_traits<Iter>::reference;
    using iterator_category = typename iterator_traits<Iter>::iterator_category;

    constexpr reverse_iterator() : current() {}
    constexpr explicit reverse_iterator(Iter x) : current(x) {}

    template <class U>
    constexpr reverse_iterator(const reverse_iterator<U>& other)
        : current(other.base()) {}

    constexpr Iter base() const { return current; }

    constexpr reference operator*() const {
        Iter tmp = current;
        return *--tmp;
    }

    constexpr pointer operator->() const {
        Iter tmp = current;
        --tmp;
        return &(*tmp);
    }

    constexpr reverse_iterator& operator++() { --current; return *this; }
    constexpr reverse_iterator  operator++(int) { auto t = *this; --current; return t; }
    constexpr reverse_iterator& operator--() { ++current; return *this; }
    constexpr reverse_iterator  operator--(int) { auto t = *this; ++current; return t; }

    constexpr reverse_iterator operator+(difference_type n) const {
        return reverse_iterator(current - n);
    }
    constexpr reverse_iterator operator-(difference_type n) const {
        return reverse_iterator(current + n);
    }
    constexpr reverse_iterator& operator+=(difference_type n) { current -= n; return *this; }
    constexpr reverse_iterator& operator-=(difference_type n) { current += n; return *this; }

    constexpr reference operator[](difference_type n) const { return *(*this + n); }

protected:
    Iter current;
};

template <class I1, class I2>
constexpr bool operator==(const reverse_iterator<I1>& a, const reverse_iterator<I2>& b) {
    return a.base() == b.base();
}

template <class I1, class I2>
constexpr bool operator!=(const reverse_iterator<I1>& a, const reverse_iterator<I2>& b) {
    return a.base() != b.base();
}

template <class I1, class I2>
constexpr bool operator<(const reverse_iterator<I1>& a, const reverse_iterator<I2>& b) {
    return a.base() > b.base();
}

template <class I1, class I2>
constexpr bool operator>(const reverse_iterator<I1>& a, const reverse_iterator<I2>& b) {
    return a.base() < b.base();
}

template <class I1, class I2>
constexpr bool operator<=(const reverse_iterator<I1>& a, const reverse_iterator<I2>& b) {
    return a.base() >= b.base();
}

template <class I1, class I2>
constexpr bool operator>=(const reverse_iterator<I1>& a, const reverse_iterator<I2>& b) {
    return a.base() <= b.base();
}

template <class Iter>
constexpr reverse_iterator<Iter> make_reverse_iterator(Iter i) {
    return reverse_iterator<Iter>(i);
}

/* ── distance / advance / next / prev ──────────────────────────────── */

namespace detail {
    template <class It>
    constexpr typename iterator_traits<It>::difference_type
    distance_impl(It first, It last, random_access_iterator_tag) {
        return last - first;
    }

    template <class It>
    constexpr typename iterator_traits<It>::difference_type
    distance_impl(It first, It last, input_iterator_tag) {
        typename iterator_traits<It>::difference_type n = 0;
        while (first != last) { ++first; ++n; }
        return n;
    }
}

template <class It>
constexpr typename iterator_traits<It>::difference_type
distance(It first, It last) {
    return detail::distance_impl(first, last,
        typename iterator_traits<It>::iterator_category{});
}

template <class It, class Distance>
constexpr void advance(It& it, Distance n) {
    if constexpr (is_base_of_v<random_access_iterator_tag,
                  typename iterator_traits<It>::iterator_category>) {
        it += n;
    } else if constexpr (is_base_of_v<bidirectional_iterator_tag,
                         typename iterator_traits<It>::iterator_category>) {
        if (n > 0) while (n--) ++it;
        else       while (n++) --it;
    } else {
        while (n > 0) { ++it; --n; }
    }
}

template <class It>
constexpr It next(It it, typename iterator_traits<It>::difference_type n = 1) {
    advance(it, n);
    return it;
}

template <class It>
constexpr It prev(It it, typename iterator_traits<It>::difference_type n = 1) {
    advance(it, -n);
    return it;
}

/* ── begin / end for arrays ────────────────────────────────────────── */

template <class T, size_t N>
constexpr T* begin(T (&arr)[N]) noexcept { return arr; }

template <class T, size_t N>
constexpr T* end(T (&arr)[N]) noexcept { return arr + N; }

/* ── Container-based begin/end ─────────────────────────────────────── */

template <class C>
constexpr auto begin(C& c) -> decltype(c.begin()) { return c.begin(); }

template <class C>
constexpr auto begin(const C& c) -> decltype(c.begin()) { return c.begin(); }

template <class C>
constexpr auto end(C& c) -> decltype(c.end()) { return c.end(); }

template <class C>
constexpr auto end(const C& c) -> decltype(c.end()) { return c.end(); }

template <class C>
constexpr auto cbegin(const C& c) -> decltype(c.begin()) { return c.begin(); }

template <class C>
constexpr auto cend(const C& c) -> decltype(c.end()) { return c.end(); }

/* ── size / data / empty (C++17) ───────────────────────────────────── */

template <class C>
constexpr auto size(const C& c) -> decltype(c.size()) { return c.size(); }

template <class T, size_t N>
constexpr size_t size(const T (&)[N]) noexcept { return N; }

template <class C>
constexpr auto data(C& c) -> decltype(c.data()) { return c.data(); }

template <class C>
constexpr auto data(const C& c) -> decltype(c.data()) { return c.data(); }

template <class T, size_t N>
constexpr T* data(T (&arr)[N]) noexcept { return arr; }

template <class C>
[[nodiscard]] constexpr auto empty(const C& c) -> decltype(c.empty()) { return c.empty(); }

template <class T, size_t N>
[[nodiscard]] constexpr bool empty(const T (&)[N]) noexcept { return false; }

} // namespace std

#endif
