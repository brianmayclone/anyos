/*
 * Copyright (c) 2024-2026 Christian Moeller
 * SPDX-License-Identifier: MIT
 *
 * <map> — ordered associative container backed by Red-Black tree.
 */

#ifndef _LIBCXX_MAP
#define _LIBCXX_MAP

#include <cstddef>
#include <cstdlib>
#include <functional>
#include <initializer_list>
#include <iterator>
#include <new>
#include <utility>

namespace std {

namespace detail {

/* ── Red-Black tree node ───────────────────────────────────────────── */

#ifndef _LIBCXX_RB_COLOR_DEFINED
#define _LIBCXX_RB_COLOR_DEFINED
enum rb_color : unsigned char { RED, BLACK };
#endif

template <class K, class V>
struct rb_node {
    pair<const K, V> kv;
    rb_node* left;
    rb_node* right;
    rb_node* parent;
    rb_color color;

    template <class... Args>
    rb_node(Args&&... args)
        : kv(forward<Args>(args)...), left(nullptr), right(nullptr),
          parent(nullptr), color(RED) {}
};

/* ── Red-Black tree ────────────────────────────────────────────────── */

template <class K, class V, class Compare>
class rb_tree {
public:
    using node_type = rb_node<K, V>;
    using value_type = pair<const K, V>;

private:
    node_type* _root;
    size_t     _count;
    Compare    _comp;

    /* Rotations */
    void _rotate_left(node_type* x) {
        node_type* y = x->right;
        x->right = y->left;
        if (y->left) y->left->parent = x;
        y->parent = x->parent;
        if (!x->parent) _root = y;
        else if (x == x->parent->left) x->parent->left = y;
        else x->parent->right = y;
        y->left = x;
        x->parent = y;
    }

    void _rotate_right(node_type* x) {
        node_type* y = x->left;
        x->left = y->right;
        if (y->right) y->right->parent = x;
        y->parent = x->parent;
        if (!x->parent) _root = y;
        else if (x == x->parent->right) x->parent->right = y;
        else x->parent->left = y;
        y->right = x;
        x->parent = y;
    }

    void _insert_fix(node_type* z) {
        while (z->parent && z->parent->color == RED) {
            if (z->parent == z->parent->parent->left) {
                node_type* y = z->parent->parent->right;
                if (y && y->color == RED) {
                    z->parent->color = BLACK;
                    y->color = BLACK;
                    z->parent->parent->color = RED;
                    z = z->parent->parent;
                } else {
                    if (z == z->parent->right) {
                        z = z->parent;
                        _rotate_left(z);
                    }
                    z->parent->color = BLACK;
                    z->parent->parent->color = RED;
                    _rotate_right(z->parent->parent);
                }
            } else {
                node_type* y = z->parent->parent->left;
                if (y && y->color == RED) {
                    z->parent->color = BLACK;
                    y->color = BLACK;
                    z->parent->parent->color = RED;
                    z = z->parent->parent;
                } else {
                    if (z == z->parent->left) {
                        z = z->parent;
                        _rotate_right(z);
                    }
                    z->parent->color = BLACK;
                    z->parent->parent->color = RED;
                    _rotate_left(z->parent->parent);
                }
            }
        }
        _root->color = BLACK;
    }

    void _transplant(node_type* u, node_type* v) {
        if (!u->parent) _root = v;
        else if (u == u->parent->left) u->parent->left = v;
        else u->parent->right = v;
        if (v) v->parent = u->parent;
    }

    void _erase_fix(node_type* x, node_type* x_parent) {
        while (x != _root && (!x || x->color == BLACK)) {
            if (x == (x_parent ? x_parent->left : nullptr)) {
                node_type* w = x_parent->right;
                if (w && w->color == RED) {
                    w->color = BLACK;
                    x_parent->color = RED;
                    _rotate_left(x_parent);
                    w = x_parent->right;
                }
                if ((!w->left || w->left->color == BLACK) &&
                    (!w->right || w->right->color == BLACK)) {
                    w->color = RED;
                    x = x_parent;
                    x_parent = x->parent;
                } else {
                    if (!w->right || w->right->color == BLACK) {
                        if (w->left) w->left->color = BLACK;
                        w->color = RED;
                        _rotate_right(w);
                        w = x_parent->right;
                    }
                    w->color = x_parent->color;
                    x_parent->color = BLACK;
                    if (w->right) w->right->color = BLACK;
                    _rotate_left(x_parent);
                    x = _root;
                }
            } else {
                node_type* w = x_parent->left;
                if (w && w->color == RED) {
                    w->color = BLACK;
                    x_parent->color = RED;
                    _rotate_right(x_parent);
                    w = x_parent->left;
                }
                if ((!w->right || w->right->color == BLACK) &&
                    (!w->left || w->left->color == BLACK)) {
                    w->color = RED;
                    x = x_parent;
                    x_parent = x->parent;
                } else {
                    if (!w->left || w->left->color == BLACK) {
                        if (w->right) w->right->color = BLACK;
                        w->color = RED;
                        _rotate_left(w);
                        w = x_parent->left;
                    }
                    w->color = x_parent->color;
                    x_parent->color = BLACK;
                    if (w->left) w->left->color = BLACK;
                    _rotate_right(x_parent);
                    x = _root;
                }
            }
        }
        if (x) x->color = BLACK;
    }

    static node_type* _minimum(node_type* n) {
        while (n->left) n = n->left;
        return n;
    }

    static node_type* _maximum(node_type* n) {
        while (n->right) n = n->right;
        return n;
    }

    static node_type* _successor(node_type* n) {
        if (n->right) return _minimum(n->right);
        node_type* p = n->parent;
        while (p && n == p->right) { n = p; p = p->parent; }
        return p;
    }

    static node_type* _predecessor(node_type* n) {
        if (n->left) return _maximum(n->left);
        node_type* p = n->parent;
        while (p && n == p->left) { n = p; p = p->parent; }
        return p;
    }

    void _destroy(node_type* n) {
        if (!n) return;
        _destroy(n->left);
        _destroy(n->right);
        n->kv.~value_type();
        std::free(n);
    }

    node_type* _clone(const node_type* n, node_type* parent) {
        if (!n) return nullptr;
        void* mem = std::malloc(sizeof(node_type));
        if (!mem) std::abort();
        node_type* c = ::new (mem) node_type(n->kv);
        c->color = n->color;
        c->parent = parent;
        c->left  = _clone(n->left, c);
        c->right = _clone(n->right, c);
        return c;
    }

public:
    rb_tree() : _root(nullptr), _count(0), _comp() {}
    rb_tree(const Compare& comp) : _root(nullptr), _count(0), _comp(comp) {}

    rb_tree(const rb_tree& other) : _root(nullptr), _count(other._count), _comp(other._comp) {
        _root = _clone(other._root, nullptr);
    }

    rb_tree(rb_tree&& other) noexcept
        : _root(other._root), _count(other._count), _comp(std::move(other._comp)) {
        other._root = nullptr;
        other._count = 0;
    }

    ~rb_tree() { _destroy(_root); }

    rb_tree& operator=(const rb_tree& other) {
        if (this != &other) {
            _destroy(_root);
            _root = _clone(other._root, nullptr);
            _count = other._count;
            _comp = other._comp;
        }
        return *this;
    }

    rb_tree& operator=(rb_tree&& other) noexcept {
        if (this != &other) {
            _destroy(_root);
            _root = other._root;
            _count = other._count;
            _comp = std::move(other._comp);
            other._root = nullptr;
            other._count = 0;
        }
        return *this;
    }

    size_t size() const { return _count; }
    bool empty() const { return _count == 0; }

    node_type* root() { return _root; }
    const node_type* root() const { return _root; }

    node_type* first() { return _root ? _minimum(_root) : nullptr; }
    const node_type* first() const { return _root ? _minimum(const_cast<node_type*>(_root)) : nullptr; }

    static node_type* next(node_type* n) { return _successor(n); }
    static const node_type* next(const node_type* n) { return _successor(const_cast<node_type*>(n)); }

    node_type* find_node(const K& key) {
        node_type* n = _root;
        while (n) {
            if (_comp(key, n->kv.first)) n = n->left;
            else if (_comp(n->kv.first, key)) n = n->right;
            else return n;
        }
        return nullptr;
    }

    const node_type* find_node(const K& key) const {
        return const_cast<rb_tree*>(this)->find_node(key);
    }

    node_type* lower_bound_node(const K& key) {
        node_type* result = nullptr;
        node_type* n = _root;
        while (n) {
            if (!_comp(n->kv.first, key)) { result = n; n = n->left; }
            else n = n->right;
        }
        return result;
    }

    pair<node_type*, bool> insert_unique(const value_type& kv) {
        node_type* parent = nullptr;
        node_type* n = _root;
        while (n) {
            parent = n;
            if (_comp(kv.first, n->kv.first)) n = n->left;
            else if (_comp(n->kv.first, kv.first)) n = n->right;
            else return {n, false}; /* Key exists */
        }

        void* mem = std::malloc(sizeof(node_type));
        if (!mem) std::abort();
        node_type* z = ::new (mem) node_type(kv);
        z->parent = parent;
        if (!parent) _root = z;
        else if (_comp(kv.first, parent->kv.first)) parent->left = z;
        else parent->right = z;

        _insert_fix(z);
        ++_count;
        return {z, true};
    }

    template <class... Args>
    pair<node_type*, bool> emplace_unique(Args&&... args) {
        /* Build a temporary to extract the key */
        void* mem = std::malloc(sizeof(node_type));
        if (!mem) std::abort();
        node_type* z = ::new (mem) node_type(forward<Args>(args)...);

        node_type* parent = nullptr;
        node_type* n = _root;
        while (n) {
            parent = n;
            if (_comp(z->kv.first, n->kv.first)) n = n->left;
            else if (_comp(n->kv.first, z->kv.first)) n = n->right;
            else {
                /* Key exists — destroy temp node */
                z->kv.~value_type();
                std::free(z);
                return {n, false};
            }
        }

        z->parent = parent;
        if (!parent) _root = z;
        else if (_comp(z->kv.first, parent->kv.first)) parent->left = z;
        else parent->right = z;

        _insert_fix(z);
        ++_count;
        return {z, true};
    }

    /* Multi-insert (for multimap) */
    node_type* insert_multi(const value_type& kv) {
        node_type* parent = nullptr;
        node_type* n = _root;
        while (n) {
            parent = n;
            if (_comp(kv.first, n->kv.first)) n = n->left;
            else n = n->right;
        }

        void* mem = std::malloc(sizeof(node_type));
        if (!mem) std::abort();
        node_type* z = ::new (mem) node_type(kv);
        z->parent = parent;
        if (!parent) _root = z;
        else if (_comp(kv.first, parent->kv.first)) parent->left = z;
        else parent->right = z;

        _insert_fix(z);
        ++_count;
        return z;
    }

    void erase_node(node_type* z) {
        if (!z) return;
        node_type* y = z;
        node_type* x = nullptr;
        node_type* x_parent = nullptr;
        rb_color y_orig_color = y->color;

        if (!z->left) {
            x = z->right;
            x_parent = z->parent;
            _transplant(z, z->right);
        } else if (!z->right) {
            x = z->left;
            x_parent = z->parent;
            _transplant(z, z->left);
        } else {
            y = _minimum(z->right);
            y_orig_color = y->color;
            x = y->right;
            if (y->parent == z) {
                x_parent = y;
            } else {
                x_parent = y->parent;
                _transplant(y, y->right);
                y->right = z->right;
                y->right->parent = y;
            }
            _transplant(z, y);
            y->left = z->left;
            y->left->parent = y;
            y->color = z->color;
        }

        if (y_orig_color == BLACK && (_root != nullptr))
            _erase_fix(x, x_parent);

        z->kv.~value_type();
        std::free(z);
        --_count;
    }

    void clear() {
        _destroy(_root);
        _root = nullptr;
        _count = 0;
    }

    void swap(rb_tree& other) noexcept {
        std::swap(_root, other._root);
        std::swap(_count, other._count);
        std::swap(_comp, other._comp);
    }
};

} // namespace detail

/* ── map ───────────────────────────────────────────────────────────── */

template <class K, class V, class Compare = less<K>>
class map {
    using tree_type = detail::rb_tree<K, V, Compare>;
    using node_type = typename tree_type::node_type;

    tree_type _tree;

public:
    using key_type        = K;
    using mapped_type     = V;
    using value_type      = pair<const K, V>;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using key_compare     = Compare;
    using reference       = value_type&;
    using const_reference = const value_type&;

    /* ── Iterator ──────────────────────────────────────────────────── */

    class iterator {
        node_type* _node;
        friend class map;
    public:
        using value_type        = pair<const K, V>;
        using reference         = value_type&;
        using pointer           = value_type*;
        using difference_type   = ptrdiff_t;
        using iterator_category = bidirectional_iterator_tag;

        iterator() : _node(nullptr) {}
        explicit iterator(node_type* n) : _node(n) {}

        reference operator*()  const { return _node->kv; }
        pointer   operator->() const { return &_node->kv; }

        iterator& operator++() { _node = tree_type::next(_node); return *this; }
        iterator  operator++(int) { auto t = *this; ++*this; return t; }

        bool operator==(const iterator& o) const { return _node == o._node; }
        bool operator!=(const iterator& o) const { return _node != o._node; }
    };

    class const_iterator {
        const node_type* _node;
        friend class map;
    public:
        using value_type        = pair<const K, V>;
        using reference         = const value_type&;
        using pointer           = const value_type*;
        using difference_type   = ptrdiff_t;
        using iterator_category = bidirectional_iterator_tag;

        const_iterator() : _node(nullptr) {}
        explicit const_iterator(const node_type* n) : _node(n) {}
        const_iterator(const iterator& it) : _node(it._node) {}

        reference operator*()  const { return _node->kv; }
        pointer   operator->() const { return &_node->kv; }

        const_iterator& operator++() { _node = tree_type::next(_node); return *this; }
        const_iterator  operator++(int) { auto t = *this; ++*this; return t; }

        bool operator==(const const_iterator& o) const { return _node == o._node; }
        bool operator!=(const const_iterator& o) const { return _node != o._node; }
    };

    /* ── Constructors ──────────────────────────────────────────────── */

    map() : _tree() {}
    explicit map(const Compare& comp) : _tree(comp) {}

    map(initializer_list<value_type> il) : _tree() {
        for (auto& p : il) _tree.insert_unique(p);
    }

    map(const map&) = default;
    map(map&&) noexcept = default;
    map& operator=(const map&) = default;
    map& operator=(map&&) noexcept = default;

    /* ── Capacity ──────────────────────────────────────────────────── */

    [[nodiscard]] bool empty() const { return _tree.empty(); }
    size_type size() const { return _tree.size(); }

    /* ── Element access ────────────────────────────────────────────── */

    V& operator[](const K& key) {
        auto [node, inserted] = _tree.insert_unique(value_type(key, V()));
        return node->kv.second;
    }

    V& operator[](K&& key) {
        auto [node, inserted] = _tree.insert_unique(value_type(std::move(key), V()));
        return node->kv.second;
    }

    V& at(const K& key) {
        node_type* n = _tree.find_node(key);
        if (!n) std::abort();
        return n->kv.second;
    }

    const V& at(const K& key) const {
        const node_type* n = _tree.find_node(key);
        if (!n) std::abort();
        return n->kv.second;
    }

    /* ── Iterators ─────────────────────────────────────────────────── */

    iterator       begin()        { return iterator(_tree.first()); }
    const_iterator begin()  const { return const_iterator(_tree.first()); }
    const_iterator cbegin() const { return const_iterator(_tree.first()); }
    iterator       end()          { return iterator(nullptr); }
    const_iterator end()    const { return const_iterator(nullptr); }
    const_iterator cend()   const { return const_iterator(nullptr); }

    /* ── Lookup ────────────────────────────────────────────────────── */

    iterator find(const K& key) {
        return iterator(_tree.find_node(key));
    }

    const_iterator find(const K& key) const {
        return const_iterator(_tree.find_node(key));
    }

    size_type count(const K& key) const {
        return _tree.find_node(key) ? 1 : 0;
    }

    bool contains(const K& key) const {
        return _tree.find_node(key) != nullptr;
    }

    iterator lower_bound(const K& key) {
        return iterator(_tree.lower_bound_node(key));
    }

    /* ── Modifiers ─────────────────────────────────────────────────── */

    pair<iterator, bool> insert(const value_type& kv) {
        auto [node, inserted] = _tree.insert_unique(kv);
        return {iterator(node), inserted};
    }

    template <class... Args>
    pair<iterator, bool> emplace(Args&&... args) {
        auto [node, inserted] = _tree.emplace_unique(forward<Args>(args)...);
        return {iterator(node), inserted};
    }

    iterator erase(iterator pos) {
        node_type* n = pos._node;
        node_type* next = tree_type::next(n);
        _tree.erase_node(n);
        return iterator(next);
    }

    size_type erase(const K& key) {
        node_type* n = _tree.find_node(key);
        if (!n) return 0;
        _tree.erase_node(n);
        return 1;
    }

    void clear() { _tree.clear(); }

    void swap(map& other) noexcept { _tree.swap(other._tree); }
};

/* ── map comparison ────────────────────────────────────────────────── */

template <class K, class V, class C>
bool operator==(const map<K,V,C>& a, const map<K,V,C>& b) {
    if (a.size() != b.size()) return false;
    auto ai = a.begin(), bi = b.begin();
    for (; ai != a.end(); ++ai, ++bi)
        if (!(*ai == *bi)) return false;
    return true;
}

template <class K, class V, class C>
bool operator!=(const map<K,V,C>& a, const map<K,V,C>& b) { return !(a == b); }

} // namespace std

#endif
