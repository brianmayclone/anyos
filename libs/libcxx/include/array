/*
 * Copyright (c) 2024-2026 Christian Moeller
 * SPDX-License-Identifier: MIT
 *
 * <array> — fixed-size array container.
 */

#ifndef _LIBCXX_ARRAY
#define _LIBCXX_ARRAY

#include <cstddef>
#include <iterator>
#include <type_traits>
#include <utility>

namespace std {

template <class T, size_t N>
struct array {
    using value_type      = T;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using reference       = T&;
    using const_reference = const T&;
    using pointer         = T*;
    using const_pointer   = const T*;
    using iterator        = T*;
    using const_iterator  = const T*;
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    /* Aggregate — no user-declared constructors */
    T _data[N];

    /* Element access */
    constexpr reference       operator[](size_type i)       { return _data[i]; }
    constexpr const_reference operator[](size_type i) const { return _data[i]; }

    constexpr reference       at(size_type i)       { return _data[i]; }
    constexpr const_reference at(size_type i) const { return _data[i]; }

    constexpr reference       front()       { return _data[0]; }
    constexpr const_reference front() const { return _data[0]; }

    constexpr reference       back()       { return _data[N - 1]; }
    constexpr const_reference back() const { return _data[N - 1]; }

    constexpr pointer       data()       noexcept { return _data; }
    constexpr const_pointer data() const noexcept { return _data; }

    /* Iterators */
    constexpr iterator       begin()        noexcept { return _data; }
    constexpr const_iterator begin()  const noexcept { return _data; }
    constexpr const_iterator cbegin() const noexcept { return _data; }

    constexpr iterator       end()        noexcept { return _data + N; }
    constexpr const_iterator end()  const noexcept { return _data + N; }
    constexpr const_iterator cend() const noexcept { return _data + N; }

    constexpr reverse_iterator       rbegin()        noexcept { return reverse_iterator(end()); }
    constexpr const_reverse_iterator rbegin()  const noexcept { return const_reverse_iterator(end()); }
    constexpr reverse_iterator       rend()          noexcept { return reverse_iterator(begin()); }
    constexpr const_reverse_iterator rend()    const noexcept { return const_reverse_iterator(begin()); }

    /* Capacity */
    [[nodiscard]] constexpr bool      empty()    const noexcept { return N == 0; }
    constexpr size_type               size()     const noexcept { return N; }
    constexpr size_type               max_size() const noexcept { return N; }

    /* Operations */
    constexpr void fill(const T& value) {
        for (size_type i = 0; i < N; ++i)
            _data[i] = value;
    }

    constexpr void swap(array& other) noexcept {
        for (size_type i = 0; i < N; ++i)
            std::swap(_data[i], other._data[i]);
    }
};

/* Zero-size specialization */
template <class T>
struct array<T, 0> {
    using value_type      = T;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using reference       = T&;
    using const_reference = const T&;
    using pointer         = T*;
    using const_pointer   = const T*;
    using iterator        = T*;
    using const_iterator  = const T*;

    constexpr const_reference operator[](size_type) const { return *data(); }
    constexpr const_reference at(size_type) const { return *data(); }
    constexpr pointer       data()       noexcept { return nullptr; }
    constexpr const_pointer data() const noexcept { return nullptr; }

    constexpr iterator       begin()        noexcept { return nullptr; }
    constexpr const_iterator begin()  const noexcept { return nullptr; }
    constexpr iterator       end()          noexcept { return nullptr; }
    constexpr const_iterator end()    const noexcept { return nullptr; }

    [[nodiscard]] constexpr bool empty()    const noexcept { return true; }
    constexpr size_type          size()     const noexcept { return 0; }
    constexpr size_type          max_size() const noexcept { return 0; }
    constexpr void fill(const T&) {}
    constexpr void swap(array&) noexcept {}
};

/* Comparison */
template <class T, size_t N>
constexpr bool operator==(const array<T,N>& a, const array<T,N>& b) {
    for (size_t i = 0; i < N; ++i)
        if (!(a[i] == b[i])) return false;
    return true;
}

template <class T, size_t N>
constexpr bool operator!=(const array<T,N>& a, const array<T,N>& b) {
    return !(a == b);
}

template <class T, size_t N>
constexpr bool operator<(const array<T,N>& a, const array<T,N>& b) {
    for (size_t i = 0; i < N; ++i) {
        if (a[i] < b[i]) return true;
        if (b[i] < a[i]) return false;
    }
    return false;
}

/* get<I> for structured bindings */
template <size_t I, class T, size_t N>
constexpr T& get(array<T,N>& a) noexcept {
    static_assert(I < N, "index out of bounds");
    return a._data[I];
}

template <size_t I, class T, size_t N>
constexpr const T& get(const array<T,N>& a) noexcept {
    static_assert(I < N, "index out of bounds");
    return a._data[I];
}

template <size_t I, class T, size_t N>
constexpr T&& get(array<T,N>&& a) noexcept {
    static_assert(I < N, "index out of bounds");
    return move(a._data[I]);
}

} // namespace std

#endif
