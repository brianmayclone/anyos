/*
 * Copyright (c) 2024-2026 Christian Moeller
 * SPDX-License-Identifier: MIT
 *
 * <type_traits> — compile-time type introspection and transformation.
 */

#ifndef _LIBCXX_TYPE_TRAITS
#define _LIBCXX_TYPE_TRAITS

#include <cstddef>

namespace std {

/* ── integral_constant ─────────────────────────────────────────────── */

template <class T, T v>
struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    using type       = integral_constant;
    constexpr operator value_type() const noexcept { return value; }
    constexpr value_type operator()() const noexcept { return value; }
};

using true_type  = integral_constant<bool, true>;
using false_type = integral_constant<bool, false>;

/* ── Primary type categories ───────────────────────────────────────── */

template <class T> struct is_void                    : false_type {};
template <>        struct is_void<void>              : true_type {};
template <>        struct is_void<const void>        : true_type {};
template <>        struct is_void<volatile void>     : true_type {};
template <>        struct is_void<const volatile void> : true_type {};

template <class T> struct is_null_pointer                          : false_type {};
template <>        struct is_null_pointer<decltype(nullptr)>       : true_type {};
template <>        struct is_null_pointer<const decltype(nullptr)> : true_type {};

template <class T> struct is_integral                  : false_type {};
template <>        struct is_integral<bool>             : true_type {};
template <>        struct is_integral<char>             : true_type {};
template <>        struct is_integral<signed char>      : true_type {};
template <>        struct is_integral<unsigned char>    : true_type {};
template <>        struct is_integral<short>            : true_type {};
template <>        struct is_integral<unsigned short>   : true_type {};
template <>        struct is_integral<int>              : true_type {};
template <>        struct is_integral<unsigned int>     : true_type {};
template <>        struct is_integral<long>             : true_type {};
template <>        struct is_integral<unsigned long>    : true_type {};
template <>        struct is_integral<long long>        : true_type {};
template <>        struct is_integral<unsigned long long> : true_type {};
template <>        struct is_integral<char16_t>         : true_type {};
template <>        struct is_integral<char32_t>         : true_type {};
template <>        struct is_integral<wchar_t>          : true_type {};

template <class T> struct is_floating_point             : false_type {};
template <>        struct is_floating_point<float>       : true_type {};
template <>        struct is_floating_point<double>      : true_type {};
template <>        struct is_floating_point<long double> : true_type {};

template <class T> struct is_array       : false_type {};
template <class T> struct is_array<T[]>  : true_type {};
template <class T, size_t N> struct is_array<T[N]> : true_type {};

template <class T> struct is_pointer                    : false_type {};
template <class T> struct is_pointer<T*>                : true_type {};
template <class T> struct is_pointer<T* const>          : true_type {};
template <class T> struct is_pointer<T* volatile>       : true_type {};
template <class T> struct is_pointer<T* const volatile> : true_type {};

template <class T> struct is_lvalue_reference      : false_type {};
template <class T> struct is_lvalue_reference<T&>  : true_type {};

template <class T> struct is_rvalue_reference      : false_type {};
template <class T> struct is_rvalue_reference<T&&> : true_type {};

template <class T> struct is_reference      : false_type {};
template <class T> struct is_reference<T&>  : true_type {};
template <class T> struct is_reference<T&&> : true_type {};

template <class T> struct is_function : integral_constant<bool,
    !is_reference<T>::value && !is_void<T>::value && !is_array<T>::value &&
    !is_pointer<T>::value && !is_integral<T>::value && !is_floating_point<T>::value> {};

/* ── CV qualifiers ─────────────────────────────────────────────────── */

template <class T> struct is_const          : false_type {};
template <class T> struct is_const<const T> : true_type {};

template <class T> struct is_volatile             : false_type {};
template <class T> struct is_volatile<volatile T> : true_type {};

template <class T> struct remove_const            { using type = T; };
template <class T> struct remove_const<const T>   { using type = T; };

template <class T> struct remove_volatile              { using type = T; };
template <class T> struct remove_volatile<volatile T>  { using type = T; };

template <class T> struct remove_cv {
    using type = typename remove_volatile<typename remove_const<T>::type>::type;
};

template <class T> struct add_const    { using type = const T; };
template <class T> struct add_volatile { using type = volatile T; };
template <class T> struct add_cv       { using type = const volatile T; };

template <class T> using remove_const_t    = typename remove_const<T>::type;
template <class T> using remove_volatile_t = typename remove_volatile<T>::type;
template <class T> using remove_cv_t       = typename remove_cv<T>::type;
template <class T> using add_const_t       = typename add_const<T>::type;
template <class T> using add_volatile_t    = typename add_volatile<T>::type;
template <class T> using add_cv_t          = typename add_cv<T>::type;

/* ── Reference manipulation ────────────────────────────────────────── */

template <class T> struct remove_reference      { using type = T; };
template <class T> struct remove_reference<T&>  { using type = T; };
template <class T> struct remove_reference<T&&> { using type = T; };

template <class T> using remove_reference_t = typename remove_reference<T>::type;

namespace detail {
    template <class T> struct add_lvalue_ref       { using type = T&; };
    template <>        struct add_lvalue_ref<void>  { using type = void; };
    template <class T> struct add_rvalue_ref       { using type = T&&; };
    template <>        struct add_rvalue_ref<void>  { using type = void; };
}

template <class T> struct add_lvalue_reference : detail::add_lvalue_ref<T> {};
template <class T> struct add_rvalue_reference : detail::add_rvalue_ref<T> {};

template <class T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
template <class T> using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

/* ── Pointer manipulation ──────────────────────────────────────────── */

template <class T> struct remove_pointer                    { using type = T; };
template <class T> struct remove_pointer<T*>                { using type = T; };
template <class T> struct remove_pointer<T* const>          { using type = T; };
template <class T> struct remove_pointer<T* volatile>       { using type = T; };
template <class T> struct remove_pointer<T* const volatile> { using type = T; };

template <class T> using remove_pointer_t = typename remove_pointer<T>::type;

template <class T> struct add_pointer {
    using type = typename remove_reference<T>::type*;
};
template <class T> using add_pointer_t = typename add_pointer<T>::type;

/* ── Array manipulation ────────────────────────────────────────────── */

template <class T>           struct remove_extent       { using type = T; };
template <class T>           struct remove_extent<T[]>  { using type = T; };
template <class T, size_t N> struct remove_extent<T[N]> { using type = T; };

template <class T> using remove_extent_t = typename remove_extent<T>::type;

/* ── Type relationships ────────────────────────────────────────────── */

template <class T, class U> struct is_same       : false_type {};
template <class T>          struct is_same<T, T> : true_type {};

template <class T, class U> inline constexpr bool is_same_v = is_same<T, U>::value;

/* ── is_base_of (uses compiler intrinsic) ──────────────────────────── */

template <class Base, class Derived>
struct is_base_of : integral_constant<bool, __is_base_of(Base, Derived)> {};

template <class Base, class Derived>
inline constexpr bool is_base_of_v = is_base_of<Base, Derived>::value;

/* ── is_convertible (compiler intrinsic) ───────────────────────────── */

template <class From, class To>
struct is_convertible : integral_constant<bool, __is_convertible_to(From, To)> {};

template <class From, class To>
inline constexpr bool is_convertible_v = is_convertible<From, To>::value;

/* ── is_trivially_* (compiler intrinsics) ──────────────────────────── */

template <class T>
struct is_trivially_copyable : integral_constant<bool, __is_trivially_copyable(T)> {};

template <class T>
struct is_trivially_destructible : integral_constant<bool, __is_trivially_destructible(T)> {};

template <class T>
struct is_trivial : integral_constant<bool, __is_trivial(T)> {};

template <class T>
struct is_standard_layout : integral_constant<bool, __is_standard_layout(T)> {};

template <class T>
struct is_pod : integral_constant<bool, __is_pod(T)> {};

template <class T>
struct is_empty : integral_constant<bool, __is_empty(T)> {};

template <class T>
struct is_abstract : integral_constant<bool, __is_abstract(T)> {};

template <class T>
struct is_polymorphic : integral_constant<bool, __is_polymorphic(T)> {};

template <class T>
struct is_final : integral_constant<bool, __is_final(T)> {};

template <class T>
struct is_enum : integral_constant<bool, __is_enum(T)> {};

template <class T>
struct is_union : integral_constant<bool, __is_union(T)> {};

template <class T>
struct is_class : integral_constant<bool, __is_class(T)> {};

/* ── Composite type categories ─────────────────────────────────────── */

template <class T> struct is_arithmetic
    : integral_constant<bool, is_integral<T>::value || is_floating_point<T>::value> {};

template <class T> struct is_fundamental
    : integral_constant<bool, is_arithmetic<T>::value || is_void<T>::value ||
                              is_null_pointer<T>::value> {};

template <class T> struct is_scalar
    : integral_constant<bool, is_arithmetic<T>::value || is_pointer<T>::value ||
                              is_null_pointer<T>::value || is_enum<T>::value> {};

template <class T> struct is_object
    : integral_constant<bool, !is_function<T>::value && !is_reference<T>::value &&
                              !is_void<T>::value> {};

/* ── Type properties (variable templates) ──────────────────────────── */

template <class T> inline constexpr bool is_void_v            = is_void<T>::value;
template <class T> inline constexpr bool is_integral_v        = is_integral<T>::value;
template <class T> inline constexpr bool is_floating_point_v  = is_floating_point<T>::value;
template <class T> inline constexpr bool is_array_v           = is_array<T>::value;
template <class T> inline constexpr bool is_pointer_v         = is_pointer<T>::value;
template <class T> inline constexpr bool is_reference_v       = is_reference<T>::value;
template <class T> inline constexpr bool is_const_v           = is_const<T>::value;
template <class T> inline constexpr bool is_volatile_v        = is_volatile<T>::value;
template <class T> inline constexpr bool is_arithmetic_v      = is_arithmetic<T>::value;
template <class T> inline constexpr bool is_enum_v            = is_enum<T>::value;
template <class T> inline constexpr bool is_class_v           = is_class<T>::value;
template <class T> inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<T>::value;

/* ── enable_if / conditional ───────────────────────────────────────── */

template <bool B, class T = void> struct enable_if {};
template <class T>                struct enable_if<true, T> { using type = T; };

template <bool B, class T = void>
using enable_if_t = typename enable_if<B, T>::type;

template <bool B, class T, class F> struct conditional            { using type = T; };
template <class T, class F>         struct conditional<false,T,F> { using type = F; };

template <bool B, class T, class F>
using conditional_t = typename conditional<B, T, F>::type;

/* ── decay ─────────────────────────────────────────────────────────── */

template <class T>
struct decay {
private:
    using U = remove_reference_t<T>;
public:
    using type = conditional_t<
        is_array<U>::value,
        remove_extent_t<U>*,
        conditional_t<
            is_function<U>::value,
            add_pointer_t<U>,
            remove_cv_t<U>
        >
    >;
};

template <class T> using decay_t = typename decay<T>::type;

/* ── common_type (simple 2-arg version) ────────────────────────────── */

template <class...> struct common_type;

template <class T>
struct common_type<T> { using type = decay_t<T>; };

template <class T, class U>
struct common_type<T, U> {
    using type = decay_t<decltype(true ? declval<T>() : declval<U>())>;
};

/* ── declval (forward-declared, defined in utility) ────────────────── */

template <class T>
add_rvalue_reference_t<T> declval() noexcept;

/* ── is_constructible / is_assignable (compiler intrinsics) ────────── */

template <class T, class... Args>
struct is_constructible : integral_constant<bool, __is_constructible(T, Args...)> {};

template <class T, class U>
struct is_assignable : integral_constant<bool, __is_assignable(T, U)> {};

template <class T>
struct is_default_constructible : is_constructible<T> {};

template <class T>
struct is_copy_constructible : is_constructible<T, add_lvalue_reference_t<add_const_t<T>>> {};

template <class T>
struct is_move_constructible : is_constructible<T, add_rvalue_reference_t<T>> {};

template <class T>
struct is_destructible : integral_constant<bool, __is_destructible(T)> {};

/* ── is_signed / is_unsigned ───────────────────────────────────────── */

namespace detail {
    template <class T, bool = is_arithmetic<T>::value>
    struct is_signed_helper : integral_constant<bool, T(-1) < T(0)> {};
    template <class T>
    struct is_signed_helper<T, false> : false_type {};
}

template <class T> struct is_signed   : detail::is_signed_helper<T> {};
template <class T> struct is_unsigned : integral_constant<bool,
    is_arithmetic<T>::value && !is_signed<T>::value> {};

template <class T> inline constexpr bool is_signed_v   = is_signed<T>::value;
template <class T> inline constexpr bool is_unsigned_v  = is_unsigned<T>::value;

/* ── make_signed / make_unsigned ───────────────────────────────────── */

namespace detail {
    template <class T> struct make_signed_helper;
    template <> struct make_signed_helper<char>               { using type = signed char; };
    template <> struct make_signed_helper<signed char>        { using type = signed char; };
    template <> struct make_signed_helper<unsigned char>      { using type = signed char; };
    template <> struct make_signed_helper<short>              { using type = short; };
    template <> struct make_signed_helper<unsigned short>     { using type = short; };
    template <> struct make_signed_helper<int>                { using type = int; };
    template <> struct make_signed_helper<unsigned int>       { using type = int; };
    template <> struct make_signed_helper<long>               { using type = long; };
    template <> struct make_signed_helper<unsigned long>      { using type = long; };
    template <> struct make_signed_helper<long long>          { using type = long long; };
    template <> struct make_signed_helper<unsigned long long> { using type = long long; };

    template <class T> struct make_unsigned_helper;
    template <> struct make_unsigned_helper<char>               { using type = unsigned char; };
    template <> struct make_unsigned_helper<signed char>        { using type = unsigned char; };
    template <> struct make_unsigned_helper<unsigned char>      { using type = unsigned char; };
    template <> struct make_unsigned_helper<short>              { using type = unsigned short; };
    template <> struct make_unsigned_helper<unsigned short>     { using type = unsigned short; };
    template <> struct make_unsigned_helper<int>                { using type = unsigned int; };
    template <> struct make_unsigned_helper<unsigned int>       { using type = unsigned int; };
    template <> struct make_unsigned_helper<long>               { using type = unsigned long; };
    template <> struct make_unsigned_helper<unsigned long>      { using type = unsigned long; };
    template <> struct make_unsigned_helper<long long>          { using type = unsigned long long; };
    template <> struct make_unsigned_helper<unsigned long long> { using type = unsigned long long; };
}

template <class T> struct make_signed   { using type = typename detail::make_signed_helper<remove_cv_t<T>>::type; };
template <class T> struct make_unsigned { using type = typename detail::make_unsigned_helper<remove_cv_t<T>>::type; };

template <class T> using make_signed_t   = typename make_signed<T>::type;
template <class T> using make_unsigned_t = typename make_unsigned<T>::type;

/* ── void_t (C++17) ───────────────────────────────────────────────── */

template <class...> using void_t = void;

/* ── conjunction / disjunction / negation (C++17) ──────────────────── */

template <class...> struct conjunction : true_type {};
template <class B>  struct conjunction<B> : B {};
template <class B, class... Bn>
struct conjunction<B, Bn...> : conditional_t<bool(B::value), conjunction<Bn...>, B> {};

template <class...> struct disjunction : false_type {};
template <class B>  struct disjunction<B> : B {};
template <class B, class... Bn>
struct disjunction<B, Bn...> : conditional_t<bool(B::value), B, disjunction<Bn...>> {};

template <class B>
struct negation : integral_constant<bool, !bool(B::value)> {};

/* ── alignment_of / aligned_storage ────────────────────────────────── */

template <class T>
struct alignment_of : integral_constant<size_t, alignof(T)> {};

template <size_t Len, size_t Align>
struct aligned_storage {
    struct type {
        alignas(Align) unsigned char data[Len];
    };
};

template <size_t Len, size_t Align>
using aligned_storage_t = typename aligned_storage<Len, Align>::type;

} // namespace std

#endif
