/*
 * Copyright (c) 2024-2026 Christian Moeller
 * SPDX-License-Identifier: MIT
 *
 * std::initializer_list â€” compiler intrinsic support.
 * The compiler generates references to this type for brace-init lists.
 */

#ifndef _LIBCXX_INITIALIZER_LIST
#define _LIBCXX_INITIALIZER_LIST

#include <cstddef>

namespace std {

template <class T>
class initializer_list {
public:
    using value_type      = T;
    using reference       = const T&;
    using const_reference = const T&;
    using size_type       = size_t;
    using iterator        = const T*;
    using const_iterator  = const T*;

private:
    /* These are set by the compiler */
    const T* _begin;
    size_t   _size;

    /* Called by the compiler */
    constexpr initializer_list(const T* b, size_t s) noexcept
        : _begin(b), _size(s) {}

public:
    constexpr initializer_list() noexcept : _begin(nullptr), _size(0) {}

    constexpr size_t size()  const noexcept { return _size; }
    constexpr const T* begin() const noexcept { return _begin; }
    constexpr const T* end()   const noexcept { return _begin + _size; }
};

template <class T>
constexpr const T* begin(initializer_list<T> il) noexcept { return il.begin(); }

template <class T>
constexpr const T* end(initializer_list<T> il) noexcept { return il.end(); }

} // namespace std

#endif
