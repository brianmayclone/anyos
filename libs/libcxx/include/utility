/*
 * Copyright (c) 2024-2026 Christian Moeller
 * SPDX-License-Identifier: MIT
 *
 * <utility> — move, forward, swap, pair, integer_sequence.
 */

#ifndef _LIBCXX_UTILITY
#define _LIBCXX_UTILITY

#include <type_traits>
#include <cstddef>

namespace std {

/* ── move / forward ────────────────────────────────────────────────── */

template <class T>
constexpr remove_reference_t<T>&& move(T&& t) noexcept {
    return static_cast<remove_reference_t<T>&&>(t);
}

template <class T>
constexpr T&& forward(remove_reference_t<T>& t) noexcept {
    return static_cast<T&&>(t);
}

template <class T>
constexpr T&& forward(remove_reference_t<T>&& t) noexcept {
    static_assert(!is_lvalue_reference<T>::value,
                  "cannot forward an rvalue as an lvalue");
    return static_cast<T&&>(t);
}

/* ── declval ───────────────────────────────────────────────────────── */

template <class T>
add_rvalue_reference_t<T> declval() noexcept;

/* ── swap ──────────────────────────────────────────────────────────── */

template <class T>
constexpr void swap(T& a, T& b) noexcept {
    T tmp = move(a);
    a = move(b);
    b = move(tmp);
}

template <class T, size_t N>
constexpr void swap(T (&a)[N], T (&b)[N]) noexcept {
    for (size_t i = 0; i < N; ++i)
        swap(a[i], b[i]);
}

/* ── exchange ──────────────────────────────────────────────────────── */

template <class T, class U = T>
constexpr T exchange(T& obj, U&& new_value) noexcept {
    T old = move(obj);
    obj = forward<U>(new_value);
    return old;
}

/* ── pair ──────────────────────────────────────────────────────────── */

template <class T1, class T2>
struct pair {
    using first_type  = T1;
    using second_type = T2;

    T1 first;
    T2 second;

    constexpr pair() : first(), second() {}

    constexpr pair(const T1& a, const T2& b)
        : first(a), second(b) {}

    template <class U1, class U2>
    constexpr pair(U1&& a, U2&& b)
        : first(forward<U1>(a)), second(forward<U2>(b)) {}

    template <class U1, class U2>
    constexpr pair(const pair<U1, U2>& other)
        : first(other.first), second(other.second) {}

    template <class U1, class U2>
    constexpr pair(pair<U1, U2>&& other)
        : first(forward<U1>(other.first)), second(forward<U2>(other.second)) {}

    pair(const pair&) = default;
    pair(pair&&) = default;
    pair& operator=(const pair&) = default;
    pair& operator=(pair&&) = default;

    constexpr void swap(pair& other) noexcept {
        using std::swap;
        swap(first, other.first);
        swap(second, other.second);
    }
};

/* ── pair comparison ───────────────────────────────────────────────── */

template <class T1, class T2>
constexpr bool operator==(const pair<T1,T2>& a, const pair<T1,T2>& b) {
    return a.first == b.first && a.second == b.second;
}

template <class T1, class T2>
constexpr bool operator!=(const pair<T1,T2>& a, const pair<T1,T2>& b) {
    return !(a == b);
}

template <class T1, class T2>
constexpr bool operator<(const pair<T1,T2>& a, const pair<T1,T2>& b) {
    return a.first < b.first || (!(b.first < a.first) && a.second < b.second);
}

template <class T1, class T2>
constexpr bool operator>(const pair<T1,T2>& a, const pair<T1,T2>& b) {
    return b < a;
}

template <class T1, class T2>
constexpr bool operator<=(const pair<T1,T2>& a, const pair<T1,T2>& b) {
    return !(b < a);
}

template <class T1, class T2>
constexpr bool operator>=(const pair<T1,T2>& a, const pair<T1,T2>& b) {
    return !(a < b);
}

/* ── make_pair ─────────────────────────────────────────────────────── */

template <class T1, class T2>
constexpr pair<decay_t<T1>, decay_t<T2>> make_pair(T1&& a, T2&& b) {
    return pair<decay_t<T1>, decay_t<T2>>(forward<T1>(a), forward<T2>(b));
}

/* ── integer_sequence (C++14) ──────────────────────────────────────── */

template <class T, T... Is>
struct integer_sequence {
    using value_type = T;
    static constexpr size_t size() noexcept { return sizeof...(Is); }
};

template <size_t... Is>
using index_sequence = integer_sequence<size_t, Is...>;

/* Use compiler builtin for integer sequence generation */
template <class T, T N>
using make_integer_sequence = __make_integer_seq<integer_sequence, T, N>;

template <size_t N>
using make_index_sequence = make_integer_sequence<size_t, N>;

template <class... T>
using index_sequence_for = make_index_sequence<sizeof...(T)>;

/* ── in_place (C++17) ──────────────────────────────────────────────── */

struct in_place_t { explicit in_place_t() = default; };
inline constexpr in_place_t in_place{};

template <class T>
struct in_place_type_t { explicit in_place_type_t() = default; };

template <size_t I>
struct in_place_index_t { explicit in_place_index_t() = default; };

} // namespace std

#endif
