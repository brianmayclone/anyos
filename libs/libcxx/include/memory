/*
 * Copyright (c) 2024-2026 Christian Moeller
 * SPDX-License-Identifier: MIT
 *
 * <memory> — smart pointers: unique_ptr, shared_ptr, make_unique/make_shared.
 *            Also addressof, uninitialized_* helpers.
 */

#ifndef _LIBCXX_MEMORY
#define _LIBCXX_MEMORY

#include <cstddef>
#include <cstdlib>
#include <new>
#include <type_traits>
#include <utility>

namespace std {

/* ── addressof ─────────────────────────────────────────────────────── */

template <class T>
constexpr T* addressof(T& r) noexcept {
    return __builtin_addressof(r);
}

/* ── default_delete ────────────────────────────────────────────────── */

template <class T>
struct default_delete {
    constexpr default_delete() noexcept = default;

    template <class U>
    default_delete(const default_delete<U>&) noexcept {}

    void operator()(T* ptr) const {
        static_assert(sizeof(T) > 0, "cannot delete incomplete type");
        delete ptr;
    }
};

template <class T>
struct default_delete<T[]> {
    constexpr default_delete() noexcept = default;

    void operator()(T* ptr) const {
        static_assert(sizeof(T) > 0, "cannot delete incomplete type");
        delete[] ptr;
    }
};

/* ── unique_ptr (single object) ────────────────────────────────────── */

template <class T, class Deleter = default_delete<T>>
class unique_ptr {
public:
    using element_type = T;
    using deleter_type = Deleter;
    using pointer      = T*;

private:
    pointer  _ptr;
    Deleter  _del;

public:
    constexpr unique_ptr() noexcept : _ptr(nullptr), _del() {}
    constexpr unique_ptr(nullptr_t) noexcept : _ptr(nullptr), _del() {}

    explicit unique_ptr(pointer p) noexcept : _ptr(p), _del() {}
    unique_ptr(pointer p, const Deleter& d) noexcept : _ptr(p), _del(d) {}
    unique_ptr(pointer p, Deleter&& d) noexcept : _ptr(p), _del(move(d)) {}

    unique_ptr(unique_ptr&& other) noexcept
        : _ptr(other.release()), _del(move(other._del)) {}

    template <class U, class D>
    unique_ptr(unique_ptr<U, D>&& other) noexcept
        : _ptr(other.release()), _del(move(other.get_deleter())) {}

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    ~unique_ptr() { reset(); }

    unique_ptr& operator=(unique_ptr&& other) noexcept {
        if (this != &other) {
            reset(other.release());
            _del = move(other._del);
        }
        return *this;
    }

    unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    /* Observers */
    pointer   get() const noexcept { return _ptr; }
    Deleter&  get_deleter() noexcept { return _del; }
    const Deleter& get_deleter() const noexcept { return _del; }
    explicit operator bool() const noexcept { return _ptr != nullptr; }

    T& operator*()  const { return *_ptr; }
    T* operator->() const noexcept { return _ptr; }

    /* Modifiers */
    pointer release() noexcept {
        pointer p = _ptr;
        _ptr = nullptr;
        return p;
    }

    void reset(pointer p = nullptr) noexcept {
        pointer old = _ptr;
        _ptr = p;
        if (old) _del(old);
    }

    void swap(unique_ptr& other) noexcept {
        std::swap(_ptr, other._ptr);
        std::swap(_del, other._del);
    }
};

/* ── unique_ptr (array specialization) ─────────────────────────────── */

template <class T, class Deleter>
class unique_ptr<T[], Deleter> {
public:
    using element_type = T;
    using deleter_type = Deleter;
    using pointer      = T*;

private:
    pointer _ptr;
    Deleter _del;

public:
    constexpr unique_ptr() noexcept : _ptr(nullptr), _del() {}
    constexpr unique_ptr(nullptr_t) noexcept : _ptr(nullptr), _del() {}
    explicit unique_ptr(pointer p) noexcept : _ptr(p), _del() {}

    unique_ptr(unique_ptr&& other) noexcept
        : _ptr(other.release()), _del(move(other._del)) {}

    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    ~unique_ptr() { reset(); }

    unique_ptr& operator=(unique_ptr&& other) noexcept {
        if (this != &other) {
            reset(other.release());
            _del = move(other._del);
        }
        return *this;
    }

    unique_ptr& operator=(nullptr_t) noexcept { reset(); return *this; }

    pointer   get() const noexcept { return _ptr; }
    Deleter&  get_deleter() noexcept { return _del; }
    explicit operator bool() const noexcept { return _ptr != nullptr; }

    T& operator[](size_t i) const { return _ptr[i]; }

    pointer release() noexcept {
        pointer p = _ptr;
        _ptr = nullptr;
        return p;
    }

    void reset(pointer p = nullptr) noexcept {
        pointer old = _ptr;
        _ptr = p;
        if (old) _del(old);
    }

    void swap(unique_ptr& other) noexcept {
        std::swap(_ptr, other._ptr);
        std::swap(_del, other._del);
    }
};

/* ── make_unique ───────────────────────────────────────────────────── */

template <class T, class... Args>
enable_if_t<!is_array<T>::value, unique_ptr<T>>
make_unique(Args&&... args) {
    return unique_ptr<T>(new T(forward<Args>(args)...));
}

template <class T>
enable_if_t<is_array<T>::value && remove_extent_t<T>(0) == 0, unique_ptr<T>>
make_unique(size_t n) {
    using Elem = remove_extent_t<T>;
    return unique_ptr<T>(new Elem[n]());
}

/* ── unique_ptr comparison ─────────────────────────────────────────── */

template <class T1, class D1, class T2, class D2>
bool operator==(const unique_ptr<T1,D1>& a, const unique_ptr<T2,D2>& b) { return a.get() == b.get(); }

template <class T1, class D1, class T2, class D2>
bool operator!=(const unique_ptr<T1,D1>& a, const unique_ptr<T2,D2>& b) { return a.get() != b.get(); }

template <class T, class D>
bool operator==(const unique_ptr<T,D>& p, nullptr_t) { return !p; }

template <class T, class D>
bool operator==(nullptr_t, const unique_ptr<T,D>& p) { return !p; }

template <class T, class D>
bool operator!=(const unique_ptr<T,D>& p, nullptr_t) { return bool(p); }

/* ── Control block for shared_ptr ──────────────────────────────────── */

namespace detail {
    struct control_block_base {
        unsigned int ref_count;
        unsigned int weak_count; /* Not fully used yet, but reserved */

        control_block_base() : ref_count(1), weak_count(0) {}
        virtual ~control_block_base() = default;
        virtual void destroy_object() = 0;
        virtual void deallocate_block() = 0;
    };

    template <class T>
    struct control_block_ptr : control_block_base {
        T* ptr;
        explicit control_block_ptr(T* p) : ptr(p) {}
        void destroy_object() override { delete ptr; ptr = nullptr; }
        void deallocate_block() override { delete this; }
    };

    /* make_shared: object and control block in single allocation */
    template <class T>
    struct control_block_inplace : control_block_base {
        alignas(T) unsigned char storage[sizeof(T)];

        template <class... Args>
        explicit control_block_inplace(Args&&... args) {
            ::new (static_cast<void*>(storage)) T(forward<Args>(args)...);
        }

        T* get_ptr() { return reinterpret_cast<T*>(storage); }

        void destroy_object() override {
            get_ptr()->~T();
        }
        void deallocate_block() override {
            /* Free the combined block (this was allocated with new) */
            delete this;
        }
    };
}

/* ── shared_ptr ────────────────────────────────────────────────────── */

template <class T>
class shared_ptr {
    template <class U> friend class shared_ptr;

    T* _ptr;
    detail::control_block_base* _cb;

    void _release() {
        if (_cb) {
            if (--_cb->ref_count == 0) {
                _cb->destroy_object();
                _cb->deallocate_block();
            }
            _ptr = nullptr;
            _cb  = nullptr;
        }
    }

    void _acquire(const shared_ptr& other) {
        _ptr = other._ptr;
        _cb  = other._cb;
        if (_cb) ++_cb->ref_count;
    }

public:
    using element_type = T;

    constexpr shared_ptr() noexcept : _ptr(nullptr), _cb(nullptr) {}
    constexpr shared_ptr(nullptr_t) noexcept : _ptr(nullptr), _cb(nullptr) {}

    explicit shared_ptr(T* p) : _ptr(p), _cb(nullptr) {
        if (p) {
            _cb = new detail::control_block_ptr<T>(p);
        }
    }

    shared_ptr(const shared_ptr& other) noexcept : _ptr(nullptr), _cb(nullptr) {
        _acquire(other);
    }

    template <class U>
    shared_ptr(const shared_ptr<U>& other) noexcept : _ptr(nullptr), _cb(nullptr) {
        _ptr = other._ptr;
        _cb  = other._cb;
        if (_cb) ++_cb->ref_count;
    }

    shared_ptr(shared_ptr&& other) noexcept : _ptr(other._ptr), _cb(other._cb) {
        other._ptr = nullptr;
        other._cb  = nullptr;
    }

    ~shared_ptr() { _release(); }

    shared_ptr& operator=(const shared_ptr& other) noexcept {
        if (this != &other) {
            _release();
            _acquire(other);
        }
        return *this;
    }

    shared_ptr& operator=(shared_ptr&& other) noexcept {
        if (this != &other) {
            _release();
            _ptr = other._ptr;
            _cb  = other._cb;
            other._ptr = nullptr;
            other._cb  = nullptr;
        }
        return *this;
    }

    void reset() noexcept { _release(); }
    void reset(T* p) { _release(); *this = shared_ptr(p); }

    /* Observers */
    T*   get() const noexcept { return _ptr; }
    T&   operator*() const { return *_ptr; }
    T*   operator->() const noexcept { return _ptr; }
    long use_count() const noexcept { return _cb ? _cb->ref_count : 0; }
    explicit operator bool() const noexcept { return _ptr != nullptr; }

    void swap(shared_ptr& other) noexcept {
        std::swap(_ptr, other._ptr);
        std::swap(_cb,  other._cb);
    }

    /* For make_shared */
    template <class U, class... Args>
    friend shared_ptr<U> make_shared(Args&&... args);
};

/* ── make_shared ───────────────────────────────────────────────────── */

template <class T, class... Args>
shared_ptr<T> make_shared(Args&&... args) {
    auto* cb = new detail::control_block_inplace<T>(forward<Args>(args)...);
    shared_ptr<T> sp;
    sp._ptr = cb->get_ptr();
    sp._cb  = cb;
    return sp;
}

/* ── shared_ptr comparison ─────────────────────────────────────────── */

template <class T, class U>
bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) { return a.get() == b.get(); }

template <class T, class U>
bool operator!=(const shared_ptr<T>& a, const shared_ptr<U>& b) { return a.get() != b.get(); }

template <class T>
bool operator==(const shared_ptr<T>& p, nullptr_t) { return !p; }

template <class T>
bool operator!=(const shared_ptr<T>& p, nullptr_t) { return bool(p); }

/* ── uninitialized memory operations ───────────────────────────────── */

template <class FwdIt>
void uninitialized_default_construct(FwdIt first, FwdIt last) {
    for (; first != last; ++first)
        ::new (static_cast<void*>(addressof(*first)))
            typename iterator_traits<FwdIt>::value_type;
}

template <class FwdIt, class T>
void uninitialized_fill(FwdIt first, FwdIt last, const T& value) {
    for (; first != last; ++first)
        ::new (static_cast<void*>(addressof(*first)))
            typename iterator_traits<FwdIt>::value_type(value);
}

template <class InIt, class FwdIt>
FwdIt uninitialized_copy(InIt first, InIt last, FwdIt dest) {
    for (; first != last; ++first, ++dest)
        ::new (static_cast<void*>(addressof(*dest)))
            typename iterator_traits<FwdIt>::value_type(*first);
    return dest;
}

template <class InIt, class FwdIt>
FwdIt uninitialized_move(InIt first, InIt last, FwdIt dest) {
    for (; first != last; ++first, ++dest)
        ::new (static_cast<void*>(addressof(*dest)))
            typename iterator_traits<FwdIt>::value_type(std::move(*first));
    return dest;
}

template <class FwdIt>
void destroy(FwdIt first, FwdIt last) {
    for (; first != last; ++first)
        first->~typename iterator_traits<FwdIt>::value_type();
}

template <class T>
void destroy_at(T* p) {
    p->~T();
}

} // namespace std

#endif
