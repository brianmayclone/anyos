//! Embedded 5x7 bitmap font for direct pixel-buffer rendering.
//!
//! Same font data as the compositor's font.rs.
//! Used when uisys draws to a WinSurface instead of making kernel syscalls.

const CHAR_W: u32 = 5;
const CHAR_H: u32 = 7;
const CELL_W: u32 = CHAR_W + 1;

/// Monospace character width for layout (8px to match kernel's 8x16 spacing).
/// We render with 5x7 glyphs but space at 8px to keep consistent layout.
pub const MONO_CHAR_W: u32 = 8;
pub const MONO_CHAR_H: u32 = 16;

/// Proportional approximation: 6px cell width (5+1 spacing).
pub const PROP_CHAR_W: u32 = CELL_W;
pub const PROP_CHAR_H: u32 = 12; // 7+5 line gap for readability

#[rustfmt::skip]
static FONT_DATA: [[u8; 7]; 95] = [
    [0x00,0x00,0x00,0x00,0x00,0x00,0x00], // ' '
    [0x04,0x04,0x04,0x04,0x04,0x00,0x04], // '!'
    [0x0A,0x0A,0x0A,0x00,0x00,0x00,0x00], // '"'
    [0x0A,0x0A,0x1F,0x0A,0x1F,0x0A,0x0A], // '#'
    [0x04,0x0F,0x14,0x0E,0x05,0x1E,0x04], // '$'
    [0x18,0x19,0x02,0x04,0x08,0x13,0x03], // '%'
    [0x0C,0x12,0x14,0x08,0x15,0x12,0x0D], // '&'
    [0x04,0x04,0x08,0x00,0x00,0x00,0x00], // '''
    [0x02,0x04,0x08,0x08,0x08,0x04,0x02], // '('
    [0x08,0x04,0x02,0x02,0x02,0x04,0x08], // ')'
    [0x00,0x04,0x15,0x0E,0x15,0x04,0x00], // '*'
    [0x00,0x04,0x04,0x1F,0x04,0x04,0x00], // '+'
    [0x00,0x00,0x00,0x00,0x04,0x04,0x08], // ','
    [0x00,0x00,0x00,0x1F,0x00,0x00,0x00], // '-'
    [0x00,0x00,0x00,0x00,0x00,0x00,0x04], // '.'
    [0x01,0x01,0x02,0x04,0x08,0x10,0x10], // '/'
    [0x0E,0x11,0x13,0x15,0x19,0x11,0x0E], // '0'
    [0x04,0x0C,0x04,0x04,0x04,0x04,0x0E], // '1'
    [0x0E,0x11,0x01,0x02,0x04,0x08,0x1F], // '2'
    [0x0E,0x11,0x01,0x06,0x01,0x11,0x0E], // '3'
    [0x02,0x06,0x0A,0x12,0x1F,0x02,0x02], // '4'
    [0x1F,0x10,0x1E,0x01,0x01,0x11,0x0E], // '5'
    [0x06,0x08,0x10,0x1E,0x11,0x11,0x0E], // '6'
    [0x1F,0x01,0x02,0x04,0x08,0x08,0x08], // '7'
    [0x0E,0x11,0x11,0x0E,0x11,0x11,0x0E], // '8'
    [0x0E,0x11,0x11,0x0F,0x01,0x02,0x0C], // '9'
    [0x00,0x00,0x04,0x00,0x04,0x00,0x00], // ':'
    [0x00,0x00,0x04,0x00,0x04,0x04,0x08], // ';'
    [0x02,0x04,0x08,0x10,0x08,0x04,0x02], // '<'
    [0x00,0x00,0x1F,0x00,0x1F,0x00,0x00], // '='
    [0x08,0x04,0x02,0x01,0x02,0x04,0x08], // '>'
    [0x0E,0x11,0x01,0x02,0x04,0x00,0x04], // '?'
    [0x0E,0x11,0x17,0x15,0x17,0x10,0x0E], // '@'
    [0x0E,0x11,0x11,0x1F,0x11,0x11,0x11], // 'A'
    [0x1E,0x11,0x11,0x1E,0x11,0x11,0x1E], // 'B'
    [0x0E,0x11,0x10,0x10,0x10,0x11,0x0E], // 'C'
    [0x1C,0x12,0x11,0x11,0x11,0x12,0x1C], // 'D'
    [0x1F,0x10,0x10,0x1E,0x10,0x10,0x1F], // 'E'
    [0x1F,0x10,0x10,0x1E,0x10,0x10,0x10], // 'F'
    [0x0E,0x11,0x10,0x17,0x11,0x11,0x0F], // 'G'
    [0x11,0x11,0x11,0x1F,0x11,0x11,0x11], // 'H'
    [0x0E,0x04,0x04,0x04,0x04,0x04,0x0E], // 'I'
    [0x07,0x02,0x02,0x02,0x02,0x12,0x0C], // 'J'
    [0x11,0x12,0x14,0x18,0x14,0x12,0x11], // 'K'
    [0x10,0x10,0x10,0x10,0x10,0x10,0x1F], // 'L'
    [0x11,0x1B,0x15,0x15,0x11,0x11,0x11], // 'M'
    [0x11,0x19,0x15,0x13,0x11,0x11,0x11], // 'N'
    [0x0E,0x11,0x11,0x11,0x11,0x11,0x0E], // 'O'
    [0x1E,0x11,0x11,0x1E,0x10,0x10,0x10], // 'P'
    [0x0E,0x11,0x11,0x11,0x15,0x12,0x0D], // 'Q'
    [0x1E,0x11,0x11,0x1E,0x14,0x12,0x11], // 'R'
    [0x0E,0x11,0x10,0x0E,0x01,0x11,0x0E], // 'S'
    [0x1F,0x04,0x04,0x04,0x04,0x04,0x04], // 'T'
    [0x11,0x11,0x11,0x11,0x11,0x11,0x0E], // 'U'
    [0x11,0x11,0x11,0x11,0x0A,0x0A,0x04], // 'V'
    [0x11,0x11,0x11,0x15,0x15,0x1B,0x11], // 'W'
    [0x11,0x11,0x0A,0x04,0x0A,0x11,0x11], // 'X'
    [0x11,0x11,0x0A,0x04,0x04,0x04,0x04], // 'Y'
    [0x1F,0x01,0x02,0x04,0x08,0x10,0x1F], // 'Z'
    [0x0E,0x08,0x08,0x08,0x08,0x08,0x0E], // '['
    [0x10,0x10,0x08,0x04,0x02,0x01,0x01], // '\'
    [0x0E,0x02,0x02,0x02,0x02,0x02,0x0E], // ']'
    [0x04,0x0A,0x11,0x00,0x00,0x00,0x00], // '^'
    [0x00,0x00,0x00,0x00,0x00,0x00,0x1F], // '_'
    [0x08,0x04,0x02,0x00,0x00,0x00,0x00], // '`'
    [0x00,0x00,0x0E,0x01,0x0F,0x11,0x0F], // 'a'
    [0x10,0x10,0x1E,0x11,0x11,0x11,0x1E], // 'b'
    [0x00,0x00,0x0E,0x11,0x10,0x11,0x0E], // 'c'
    [0x01,0x01,0x0F,0x11,0x11,0x11,0x0F], // 'd'
    [0x00,0x00,0x0E,0x11,0x1F,0x10,0x0E], // 'e'
    [0x06,0x09,0x08,0x1C,0x08,0x08,0x08], // 'f'
    [0x00,0x00,0x0F,0x11,0x0F,0x01,0x0E], // 'g'
    [0x10,0x10,0x16,0x19,0x11,0x11,0x11], // 'h'
    [0x04,0x00,0x0C,0x04,0x04,0x04,0x0E], // 'i'
    [0x02,0x00,0x06,0x02,0x02,0x12,0x0C], // 'j'
    [0x10,0x10,0x12,0x14,0x18,0x14,0x12], // 'k'
    [0x0C,0x04,0x04,0x04,0x04,0x04,0x0E], // 'l'
    [0x00,0x00,0x1A,0x15,0x15,0x11,0x11], // 'm'
    [0x00,0x00,0x16,0x19,0x11,0x11,0x11], // 'n'
    [0x00,0x00,0x0E,0x11,0x11,0x11,0x0E], // 'o'
    [0x00,0x00,0x1E,0x11,0x1E,0x10,0x10], // 'p'
    [0x00,0x00,0x0F,0x11,0x0F,0x01,0x01], // 'q'
    [0x00,0x00,0x16,0x19,0x10,0x10,0x10], // 'r'
    [0x00,0x00,0x0F,0x10,0x0E,0x01,0x1E], // 's'
    [0x08,0x08,0x1C,0x08,0x08,0x09,0x06], // 't'
    [0x00,0x00,0x11,0x11,0x11,0x13,0x0D], // 'u'
    [0x00,0x00,0x11,0x11,0x11,0x0A,0x04], // 'v'
    [0x00,0x00,0x11,0x11,0x15,0x15,0x0A], // 'w'
    [0x00,0x00,0x11,0x0A,0x04,0x0A,0x11], // 'x'
    [0x00,0x00,0x11,0x11,0x0F,0x01,0x0E], // 'y'
    [0x00,0x00,0x1F,0x02,0x04,0x08,0x1F], // 'z'
    [0x02,0x04,0x04,0x08,0x04,0x04,0x02], // '{'
    [0x04,0x04,0x04,0x04,0x04,0x04,0x04], // '|'
    [0x08,0x04,0x04,0x02,0x04,0x04,0x08], // '}'
    [0x00,0x00,0x08,0x15,0x02,0x00,0x00], // '~'
];

/// Draw text to a pixel buffer using the embedded bitmap font.
/// Uses proportional spacing (6px per char).
pub fn draw_text(
    pixels: *mut u32, stride: u32, buf_h: u32,
    x: i32, y: i32, text: *const u8, color: u32,
) {
    let mut cx = x;
    let mut i = 0usize;
    loop {
        let ch = unsafe { *text.add(i) };
        if ch == 0 {
            break;
        }
        i += 1;
        let idx = if ch >= 0x20 && ch <= 0x7E {
            (ch - 0x20) as usize
        } else {
            0
        };
        let glyph = &FONT_DATA[idx];
        for row in 0..CHAR_H as i32 {
            let py = y + row;
            if py < 0 || py >= buf_h as i32 {
                continue;
            }
            let bits = glyph[row as usize];
            for col in 0..CHAR_W as i32 {
                if bits & (0x10 >> col) != 0 {
                    let px = cx + col;
                    if px >= 0 && px < stride as i32 {
                        let di = py as usize * stride as usize + px as usize;
                        unsafe {
                            *pixels.add(di) = color;
                        }
                    }
                }
            }
        }
        cx += CELL_W as i32;
    }
}

/// Draw text using monospace spacing (8px per char) for terminal-style output.
pub fn draw_text_mono(
    pixels: *mut u32, stride: u32, buf_h: u32,
    x: i32, y: i32, text: *const u8, color: u32,
) {
    let mut cx = x;
    let y_offset = 4; // Center 7px glyph in 16px cell
    let mut i = 0usize;
    loop {
        let ch = unsafe { *text.add(i) };
        if ch == 0 {
            break;
        }
        i += 1;
        let idx = if ch >= 0x20 && ch <= 0x7E {
            (ch - 0x20) as usize
        } else {
            0
        };
        let glyph = &FONT_DATA[idx];
        for row in 0..CHAR_H as i32 {
            let py = y + y_offset + row;
            if py < 0 || py >= buf_h as i32 {
                continue;
            }
            let bits = glyph[row as usize];
            for col in 0..CHAR_W as i32 {
                if bits & (0x10 >> col) != 0 {
                    let px = cx + col + 1; // Center 5px in 8px cell
                    if px >= 0 && px < stride as i32 {
                        let di = py as usize * stride as usize + px as usize;
                        unsafe {
                            *pixels.add(di) = color;
                        }
                    }
                }
            }
        }
        cx += MONO_CHAR_W as i32;
    }
}

/// Measure proportional text width in pixels.
pub fn text_width(text: *const u8) -> u32 {
    let mut len = 0u32;
    let mut i = 0usize;
    loop {
        let ch = unsafe { *text.add(i) };
        if ch == 0 {
            break;
        }
        len += 1;
        i += 1;
    }
    if len == 0 { 0 } else { len * CELL_W - 1 }
}
